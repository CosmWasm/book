<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The idea - CosmWasm book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guide to building CosmWasm smart contracts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="../setting-up-env.html"><strong aria-hidden="true">1.</strong> Setting up the environment</a></li><li class="chapter-item expanded "><a href="../wasmd-quick-start.html"><strong aria-hidden="true">2.</strong> Quick start with wasmd</a></li><li class="chapter-item expanded affix "><li class="part-title">Smart contracts</li><li class="chapter-item expanded "><a href="../basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/rust-project.html"><strong aria-hidden="true">3.1.</strong> Create a Rust project</a></li><li class="chapter-item expanded "><a href="../basics/entry-points.html"><strong aria-hidden="true">3.2.</strong> Entry points</a></li><li class="chapter-item expanded "><a href="../basics/building-contract.html"><strong aria-hidden="true">3.3.</strong> Building the contract</a></li><li class="chapter-item expanded "><a href="../basics/query.html"><strong aria-hidden="true">3.4.</strong> Creating a query</a></li><li class="chapter-item expanded "><a href="../basics/query-testing.html"><strong aria-hidden="true">3.5.</strong> Testing a query</a></li><li class="chapter-item expanded "><a href="../basics/multitest-intro.html"><strong aria-hidden="true">3.6.</strong> Introducing multitest</a></li><li class="chapter-item expanded "><a href="../basics/state.html"><strong aria-hidden="true">3.7.</strong> Contract state</a></li><li class="chapter-item expanded "><a href="../basics/execute.html"><strong aria-hidden="true">3.8.</strong> Execution messages</a></li><li class="chapter-item expanded "><a href="../basics/events.html"><strong aria-hidden="true">3.9.</strong> Events, attributes and data</a></li><li class="chapter-item expanded "><a href="../basics/funds.html"><strong aria-hidden="true">3.10.</strong> Dealing with funds</a></li><li class="chapter-item expanded "><a href="../basics/good-practices.html"><strong aria-hidden="true">3.11.</strong> Good practices</a></li><li class="chapter-item expanded "><a href="../basics/fp-types.html"><strong aria-hidden="true">3.12.</strong> Floating point types</a></li></ol></li><li class="chapter-item expanded "><a href="../actor-model.html"><strong aria-hidden="true">4.</strong> The Actor Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../actor-model/idea.html" class="active"><strong aria-hidden="true">4.1.</strong> The idea</a></li><li class="chapter-item expanded "><a href="../actor-model/actors-in-blockchain.html"><strong aria-hidden="true">4.2.</strong> Actors in the blockchain</a></li><li class="chapter-item expanded "><a href="../actor-model/contract-as-actor.html"><strong aria-hidden="true">4.3.</strong> Contract as an actor</a></li></ol></li><li class="chapter-item expanded "><a href="../cross-contract.html"><strong aria-hidden="true">5.</strong> Cross contract communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cross-contract/design.html"><strong aria-hidden="true">5.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="../cross-contract/fixing-admin.html"><strong aria-hidden="true">5.2.</strong> Fixing admin contract</a></li><li class="chapter-item expanded "><a href="../cross-contract/map-storage.html"><strong aria-hidden="true">5.3.</strong> Map storage</a></li><li class="chapter-item expanded "><a href="../cross-contract/working-with-time.html"><strong aria-hidden="true">5.4.</strong> Working with time</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Inter-blockchain communication</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../impressum.html">Legal Information</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CosmWasm book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="idea-behind-an-actor-model"><a class="header" href="#idea-behind-an-actor-model">Idea behind an Actor Model</a></h1>
<p>The actor model is the solution to the problem of communication between smart
contracts. Let's take a look at the reasons why this particular solution is
chosen in CosmWasm, and what are the consequences of that.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>Smart contracts can be imagined as sandboxed microservices. Due to
<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> principles, it is valuable to
split responsibilities between entities. However, to split the work between
contracts themselves, there is a need to communicate between them, so if one
contract is responsible for managing group membership, it is possible to call
its functionality from another contract.</p>
<p>The traditional way to solve this problem in SW engineering is to model
services as functions that would be called with some RPC mechanism, and return
its result as a response. Even though this approach looks nice, it creates sort
of problems, in particular with shared state consistency.</p>
<p>The other approach which is far more popular in business-level modeling is to
treat entities as actors, which can perform some tasks, but without
interrupting it with calls to other contracts. Any calls to other contracts can
only be called after the whole execution is performed. When &quot;subcall&quot; is
finished, it will call the original contract back.</p>
<p>This solution may feel unnatural, and it requires different kinds of design
solutions, but it turns out to work pretty well for smart contract execution.
I will try to explain how to reason about it, and how it maps to contract
structure step by step.</p>
<h2 id="the-actor"><a class="header" href="#the-actor">The Actor</a></h2>
<p>The most important thing in the whole model is an Actor itself. So, what is
this? The Actor is a single instantiation of a contract, which can perform
several actions. When the actor finishes his job, he prepares a summary of it,
which includes the list of things that have to be done, to complete the whole
scheduled task.</p>
<p>An example of an actor is the Seller in the KFC restaurant. The first thing you
do is order your BSmart, so you are requesting action from him. So, from the
system user, you can think about this task as &quot;sell and prepare my meal&quot;, but
the action performed by the seller is just &quot;Charge payment and create order&quot;.
The first part of this operation is to create a bill and charge you for it, and
then it requests the Sandwich and Fries to be prepared by other actors,
probably chefs. Then when the chef is done with his part of the meal, he checks
if all meals are ready. If so, it calls the last actor, the waiter, to deliver
the food to you. At this point, you can receive your delivery, and the task is
considered complete.</p>
<p>The above-described workflow is kind of simplified. In particular - in a
typical restaurant, a waiter would observe the kitchen instead of being
triggered by a chef, but in the Actor model, it is not possible. Here, entities
of the system are passive and cannot observe the environment actively - they
only react to messages from other system participants. Also in KFC, the seller
would not schedule subtasks for particular chefs; instead, he would leave tasks
to be taken by them, when they are free. It is not the case, because as before -
chefs cannot actively listen to the environment. However, it would be possible
to create a contract for being a chef's dispatcher which would collect all
orders from sellers, and balance them across chefs for some reason.</p>
<h2 id="the-action"><a class="header" href="#the-action">The Action</a></h2>
<p>Actors are the model entities, but to properly communicate with them, we need
some kind of protocol. Every actor is capable of performing several actions. In
my previous KFC example, the only action seller can do is &quot;Charge payment and
create order&quot;. However, it is not always the case - our chefs were proficient
at performing both &quot;Prepare fries&quot; and &quot;Prepare Sandwich&quot; actions - and also
many more.</p>
<p>So, when we want to do something in an actor system, we schedule some action to
the actor being the closest to us, very often with some additional parameters
(as we can pick if we want to exchange fries with salad).</p>
<p>However, naming the action after the exact thing which happened in the very
contract would be misleading. Take a look at the KFC example once again. As I
mentioned, the action performed by a seller is &quot;Charge payment and create
order&quot;. The problem is, that for the client who schedules this action, it
doesn't matter what exactly is the responsibility of the actor himself - what
the client is scheduling is &quot;Prepare Meal&quot; with some description of what
exactly to prepare. So, we can say, that the action is the thing performed by
the contract itself, plus all the sub-actions it schedules.</p>
<h2 id="multi-stage-actions"><a class="header" href="#multi-stage-actions">Multi-stage Actions</a></h2>
<p>So as the whole idea makes some sense, there is the problem created by the
actor model: what if I want to perform some action in my contract, but to
completely finalize some steps, the contract has to make sure that some
sub-action he scheduled are finished?</p>
<p>Imagine that in the previous KFC situation, there is no dedicated Waiter.
Instead the Seller was serving you a meal when the Chefs finished their job.</p>
<p>This kind of pattern is so important and common that in CosmWasm, we developed
a special way to handle it, which is dedicated <code>Reply</code> action.</p>
<p>So when Seller is scheduling actions for chefs, he assigns some number to this
action (like order id) and passes it to chefs. He also remembers how many
actions he scheduled for every order id. Now every time chef is finished with
his action; he would call the special <code>Reply</code> action on Seller, in which he
would pass back the order id. Then, Seller would decrease the number of actions
left for this order, and if it reached zero, he would serve a meal.</p>
<p>Now you can say, that the <code>Reply</code> action is completely not needed, as Chefs
could just schedule any arbitrary action on Seller, like <code>Serve</code>, why is there
the special <code>Reply</code> for? The reason is abstraction and reusability. The Chefs
task is to prepare a meal, and that is all. There is no reason for him to know
why he is even preparing Fries - if it is part of the bigger task (like order
for a client), or the seller is just hungry. It is possible that not only the
seller is eligible to call the chef for food - possibly any restaurant employee
can do that just for themselves. Therefore, we need a way to be able to react
to an actor finishing his job in some universal way, to handle this situation
properly in any context.</p>
<p>It is worth noting that the <code>Reply</code> can contain some additional data. The id
assigned previously is the only required information in the <code>Reply</code> call, but
the actor can pass some additional data - <code>events</code> emitted, which are mostly
metadata (to be observed by non-blockchain applications mostly), and any
arbitrary data it wants to pass.</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>Up until this point, we were considering actors as entities performing some
job, like preparing the meal. If we are considering computer programs, such a
job would be to show something on the screen, maybe print something. This is
not the case with Smart Contracts. The only thing which can be affected by the
Smart Contract is their internal state. So, the state is arbitrary data that is
kept by the contract. Previously in the KFC example I mentioned, the Seller is
keeping in mind how many actions he scheduled for chefs are not yet finished -
this number is part of the Seller's state.</p>
<p>To give a more realistic example of a contract state, let's think about a more
real-life Smart Contract than the restaurant. Let's imagine we want to create
our currency - maybe we want to create some smart contracts-based market for
some MMORPG game. So, we need some way to be able to at least transfer currency
between players. We can do that, by creating the contract we would call
<code>MmoCurrency</code>, which would support the <code>Transfer</code> action to transfer money to
another player. Then what would be the state of such a contract? It would be
just a table mapping player names to the amount of currency they own. The
contract we just invited exists in CosmWasm examples, and it is called the
<a href="https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw20-base"><code>cw20-base</code>
contract</a>
(it is a bit more complicated, but it is its core idea).</p>
<p>And now there is a question - how is this helpful to transfer currency if I
cannot check how much of it do I own? It is a very good question, and the
answer to that is simple - the whole state of every contract in our system is
public. It is not universal for every Actor model, but it is how it works in
CosmWasm, and it is kind of forced by the nature of blockchain. Everything
happening in blockchain has to be public, and if some information should be
hidden, it has to be stored indirectly.</p>
<p>There is one very important thing about the state in CosmWasm, and it is the
state being transactional. Any updates to the state are not applied
immediately, but only when the whole action succeeds. It is very important, as
it guarantees that if something goes wrong in the contract, it is always left
in some proper state. Let's consider our <code>MmoCurrency</code> case. Imagine, that in
the <code>Transfer</code> action we first increase the receiver currency amount (by
updating the state), and only then do we decrease the sender amount. However,
before decreasing it, we need to check if a sender possesses enough funds to
perform the transaction. In case we realize that we cannot do it, we don't need
to do any rolling back by hand - we would just return a failure from the action
execution, and the state would not be updated. So, when in the contract state
is updated, it is just a local copy of this state being altered, but the
partial changes would never be visible by other contracts.</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>There is one building block in the CosmWasm approach to the Actor model, which
I haven't yet cover. As I said, the whole state of every contract is public and
available for everyone to look at. The problem is that this way of looking at
state is not very convenient - it requires users of contracts to know its
internal structure, which kind of violates the SOLID rules (Liskov substitution
principle in particular). If, for example a contract is updated and its state
structure changes a bit, another contract looking at its state would just
nevermore work. Also, it is often the case, that the contract state is kind of
simplified, and information that is relevant to the observer would be
calculated from the state.</p>
<p>This is where queries come into play. Queries are the type of messages to
contract, which does not perform any actions, so do not update any state, but
can return an answer immediately.</p>
<p>In our KFC comparison, the query would be if Seller goes to Chef to ask &quot;Do we
still have pickles available for our cheeseburgers&quot;? It can be done while
operating, and response can be used in it. It is possible because queries can
never update their state, so they do not need to be handled in a transactional
manner.</p>
<p>However, the existence of queries doesn't mean that we cannot look at the
contract's state directly - the state is still public, and the technique of
looking at them directly is called <code>Raw Queries</code>. For clarity, non-raw queries
are sometimes denoted as <code>Smart Queries</code>.</p>
<h2 id="wrapping-everything-together---transactional-call-flow"><a class="header" href="#wrapping-everything-together---transactional-call-flow">Wrapping everything together - transactional call flow</a></h2>
<p>So, we touched on many things here, and I know it may be kind of confusing.
Because of that, I would like to go through some more complicated calls to the
CosmWasm contract to visualize what the &quot;transactional state&quot; means.</p>
<p>Let's imagine two contracts:</p>
<ol>
<li>The <code>MmoCurrency</code> contract mentioned before, which can perform the
<code>Transfer</code> action, allows transferring some <code>amount</code> of currency to some
<code>receiver</code>.</li>
<li>The <code>WarriorNpc</code> contract, which would have some amount of our currency, and
he would be used by our MMO engine to pay the reward out for some quest
player could perform. It would be triggered by <code>Payout</code> action, which can be
called only by a specific client (which would be our game engine).</li>
</ol>
<p>Now here is an interesting thing - this model forces us to make our MMO more
realistic in terms of the economy that we traditionally see - it is because
<code>WarriorNpc</code> has some amount of currency, and cannot create more out of
anything. It is not always the case (the previously mentioned <code>cw20</code> has a
notion of Minting for this case), but for the sake of simplicity let's assume this
is what we want.</p>
<p>To make the quest reasonable for longer, we would make a reward for it to be
always between <code>1 mmo</code> and <code>100 mmo</code>, but it would be ideally <code>15%</code> of what
Warrior owns. This means that the quest reward decreases for every subsequent
player, until Warrior would be broke, left with nothing, and will no longer be
able to payout players.</p>
<p>So, what would the flow look like? The first game would send a <code>Payout</code> message
to the <code>WarriorNpc</code> contract, with info on who should get the reward. Warrior
would keep track of players who fulfilled the quest, to not pay out the same
person twice - there would be a list of players in his state. First, he would
check the list looking for players to pay out - if he is there, he will finish
the transaction with an error.</p>
<p>However, in most cases the player would not be on the list - so then
<code>WarriorNpc</code> would add him to the list. Now the Warrior would finish his part
of the task, and schedule the <code>Transfer</code> action to be performed by
<code>MmoCurrency</code>.</p>
<p>But there is the important thing - because <code>Transfer</code> action is actually part
of the bigger <code>Payout</code> flow, it would not be executed on the original
blockchain state, but on the local copy of it, to which the player's list is
already applied to. So if the <code>MmoCurrency</code> would for any reason takes a look
at <code>WarriorNpc</code> internal list, it would be already updated.</p>
<p>Now <code>MmoCurrency</code> is doing its job, updating the state of Warrior and player
balance (note, that our Warrior is here just treated as another player!). When
it finishes, two things may happen:</p>
<ol>
<li>There was an error - possibly Warrior is out of cash, and it can nevermore
pay for the task. In such case, none of the changes - neither updating the
list of players succeeding, nor balance changes are not applied to the
original blockchain storage, so they are like they never happened. In the
database world, it is denoted as rolling back the transaction.</li>
<li>Operation succeed - all changes on the state are now applied to the
blockchain, and any further observation of <code>MmoCurrency</code> or <code>WarriorNpc</code> by
the external world would see updated data.</li>
</ol>
<p>There is one problem - in this model, our list is not a list of players who
fulfilled the quest (as we wanted it to be), but the list of players who paid
out (as in transfer failure, the list is not updated). We can do better.</p>
<h2 id="different-ways-of-handling-responses"><a class="header" href="#different-ways-of-handling-responses">Different ways of handling responses</a></h2>
<p>Note that we didn't mention a <code>Reply</code> operation at all. So why was it not
called by <code>MmoCurrency</code> on <code>WarriorNpc</code>? The reason is that this operation is
optional. When scheduling sub-actions on another contract we may choose when
<code>Reply</code> how the result should be handled:</p>
<ol>
<li>Never call <code>Reply</code>, action fails if sub-message fails</li>
<li>Call <code>Reply</code> on success</li>
<li>Call <code>Reply</code> on failure</li>
<li>Always call <code>Reply</code></li>
</ol>
<p>So, if we do not request <code>Reply</code> to be called by subsequent contract, it will
not happen. In such a case if a sub-call fails, the whole transaction is rolled
back - sub-message failure transitively causes the original message failure. It
is probably a bit complicated for now, but I promise it would be simple if you
would did some practice with that.</p>
<p>When handling the reply, it is important to remember, that although changes are
not yet applied to the blockchain (the transaction still can be failed), the
reply handler is already working on the copy of the state with all changes made
by sub-message so far applied. In most cases, it would be a good thing, but it
has a tricky consequence - if the contract is calling itself recursively, it is
possible that subsequent call overwrote things set up in the original message.
It rarely happens, but may need special treatment in some cases - for now I
don't want to go deeply into details, but I want you to remember about what to
expect after state in the actor's flow.</p>
<p>Now let's take a look at handling results with <code>2</code>-<code>4</code> options. It is actually
interesting, that using <code>2</code>, even if the transaction is performed by sub-call
succeed, we may now take a look at the data it returned with <code>Reply</code>, and on
its final state after it finished, and we can still decide, that act as a
whole is a failure, in which case everything would be rolled back - even
currency transfer performed by external contract.</p>
<p>In our case, an interesting option is <code>3</code>. So, if the contract would call
<code>Reply</code> on failure, we can decide to claim success, and commit a transaction on
the state if the sub call failed. Why may it be relevant for us? Possibly
because our internal list was supposed to keep the list of players succeeding
with the quest, not paid out! So, if we have no more currency, we still want to
update the list!</p>
<p>The most common way to use the replies (option <code>2</code> in particular)  is to
instantiate another contract, managed by the one called. The idea is that in
those use cases, the creator contract wants to keep the address of the created
contract in its state. To do so it has to create an <code>Instantiate</code> sub-message,
and subscribe for its success response, which contains the address of the freshly
created contract.</p>
<p>In the end, you can see that performing actions in CosmWasm is built with
hierarchical state change transactions. The sub-transaction can be applied to
the blockchain only if everything succeeds, but in case that sub-transaction
failed, only its part may be rolled back, end other changes may be applied. It
is very similar to how most database systems work.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Now you have seen the power of the actor model to avoid reentrancy, properly
handle errors, and safely sandbox contracts. This helps us provide the solid
security guarantees of the CosmWasm platform. Letâ€™s get started playing around
with real contracts in the <code>wasmd</code> blockchain.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../actor-model.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../actor-model/actors-in-blockchain.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../actor-model.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../actor-model/actors-in-blockchain.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
