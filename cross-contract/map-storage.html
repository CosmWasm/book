<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Map storage - CosmWasm book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guide to building CosmWasm smart contracts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="../setting-up-env.html"><strong aria-hidden="true">1.</strong> Setting up the environment</a></li><li class="chapter-item expanded "><a href="../wasmd-quick-start.html"><strong aria-hidden="true">2.</strong> Quick start with wasmd</a></li><li class="chapter-item expanded affix "><li class="part-title">Smart contracts</li><li class="chapter-item expanded "><a href="../basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../basics/rust-project.html"><strong aria-hidden="true">3.1.</strong> Create a Rust project</a></li><li class="chapter-item expanded "><a href="../basics/entry-points.html"><strong aria-hidden="true">3.2.</strong> Entry points</a></li><li class="chapter-item expanded "><a href="../basics/building-contract.html"><strong aria-hidden="true">3.3.</strong> Building the contract</a></li><li class="chapter-item expanded "><a href="../basics/query.html"><strong aria-hidden="true">3.4.</strong> Creating a query</a></li><li class="chapter-item expanded "><a href="../basics/query-testing.html"><strong aria-hidden="true">3.5.</strong> Testing a query</a></li><li class="chapter-item expanded "><a href="../basics/multitest-intro.html"><strong aria-hidden="true">3.6.</strong> Introducing multitest</a></li><li class="chapter-item expanded "><a href="../basics/state.html"><strong aria-hidden="true">3.7.</strong> Contract state</a></li><li class="chapter-item expanded "><a href="../basics/execute.html"><strong aria-hidden="true">3.8.</strong> Execution messages</a></li><li class="chapter-item expanded "><a href="../basics/events.html"><strong aria-hidden="true">3.9.</strong> Events, attributes and data</a></li><li class="chapter-item expanded "><a href="../basics/funds.html"><strong aria-hidden="true">3.10.</strong> Dealing with funds</a></li><li class="chapter-item expanded "><a href="../basics/good-practices.html"><strong aria-hidden="true">3.11.</strong> Good practices</a></li><li class="chapter-item expanded "><a href="../basics/fp-types.html"><strong aria-hidden="true">3.12.</strong> Floating point types</a></li></ol></li><li class="chapter-item expanded "><a href="../actor-model.html"><strong aria-hidden="true">4.</strong> The Actor Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../actor-model/idea.html"><strong aria-hidden="true">4.1.</strong> The idea</a></li><li class="chapter-item expanded "><a href="../actor-model/actors-in-blockchain.html"><strong aria-hidden="true">4.2.</strong> Actors in the blockchain</a></li><li class="chapter-item expanded "><a href="../actor-model/contract-as-actor.html"><strong aria-hidden="true">4.3.</strong> Contract as an actor</a></li></ol></li><li class="chapter-item expanded "><a href="../cross-contract.html"><strong aria-hidden="true">5.</strong> Cross contract communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cross-contract/design.html"><strong aria-hidden="true">5.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="../cross-contract/fixing-admin.html"><strong aria-hidden="true">5.2.</strong> Fixing admin contract</a></li><li class="chapter-item expanded "><a href="../cross-contract/map-storage.html" class="active"><strong aria-hidden="true">5.3.</strong> Map storage</a></li><li class="chapter-item expanded "><a href="../cross-contract/working-with-time.html"><strong aria-hidden="true">5.4.</strong> Working with time</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Inter-blockchain communication</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../impressum.html">Legal Information</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CosmWasm book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="map-storage"><a class="header" href="#map-storage">Map storage</a></h1>
<p>There is one thing to be immediately improved in the admin contract. Let's
check the contract state:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use cw_storage_plus::Item;
</span><span class="boring">
</span>pub const ADMINS: Item&lt;Vec&lt;Addr&gt;&gt; = Item::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Note that we keep our admin list as a single vector. However, in the whole
contract, in most cases, we access only a single element of this vector.</p>
<p>This is not ideal, as now, whenever we want to access the single admin entry,
we have first to deserialize the list containing all of them and then iterate
over them until we find the interesting one. This might consume a serious
amount of gas and is completely unnecessary overhead - we can avoid that using
the <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html">Map</a>
storage accessor.</p>
<h2 id="the-map-storage"><a class="header" href="#the-map-storage">The <code>Map</code> storage</a></h2>
<p>First, let's define a map - in this context, it would be a set of keys with values
assigned to them, just like a <code>HashMap</code> in Rust or dictionaries in many languages.
We define it as similar to an <code>Item</code>, but this time we need two types - the key type
and the value type:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cw_storage_plus::Map;

pub const STR_TO_INT_MAP: Map&lt;String, u64&gt; = Map::new(&quot;str_to_int_map&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Then to store some items on the <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html"><code>Map</code></a>,
we use a
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.save"><code>save</code></a>
method - same as for an <code>Item</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>STR_TO_INT_MAP.save(deps.storage, &quot;ten&quot;.to_owned(), 10);
STR_TO_INT_MAP.save(deps.storage, &quot;one&quot;.to_owned(), 1);
<span class="boring">}
</span></code></pre></pre>
<p>Accessing entries in the map is also as easy as reading an item:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ten = STR_TO_INT_MAP.load(deps.storage, &quot;ten&quot;.to_owned())?;
assert_eq!(ten, 10);

let two = STR_TO_INT_MAP.may_load(deps.storage, &quot;two&quot;.to_owned())?;
assert_eq!(two, None);
<span class="boring">}
</span></code></pre></pre>
<p>Obviously, if the element is missing in the map, the
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.load"><code>load</code></a>
function will result in an error - just like for an item. On the other hand -
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.may_load"><code>may_load</code></a>
returns a <code>Some</code> variant when element exits.</p>
<p>Another very useful accessor that is specific to the map is the
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.has"><code>has</code></a>
function, which checks for the existence of the key in the map:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let contains = STR_TO_INT_MAP.has(deps.storage, &quot;three&quot;.to_owned())?;
assert!(!contains);
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we can iterate over elements of the maps - either its keys or key-value
pairs:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::Order;

for k in STR_TO_INT_MAP.keys(deps.storage, None, None, Order::Ascending) {
    let _addr = deps.api.addr_validate(k?);
}

for item in STR_TO_INT_MAP.range(deps.storage, None, None, Order::Ascending) {
    let (_key, _value) = item?;
}
<span class="boring">}
</span></code></pre></pre>
<p>First, you might wonder about extra values passed to
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.keys"><code>keys</code></a>
and
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.range"><code>range</code></a> -
those are in order: lower and higher bounds of iterated elements, and the order
elements should be traversed.</p>
<p>While working with typical Rust iterators, you would probably first create an
iterator over all the elements and then somehow skip those you are not
interested in. After that, you will stop after the last interesting element.</p>
<p>It would more often than not require accessing elements you filter out, and
this is the problem - it requires reading the element from the storage. And
reading it from the storage is the expensive part of working with data, which
we try to avoid as much as possible. One way to do it is to instruct the Map
where to start and stop deserializing elements from storage so it never reaches
those outside the range.</p>
<p>Another critical thing to notice is that the iterator returned by both keys and
range functions are not iterators over elements - they are iterators over <code>Result</code>s.
It is a thing because, as it is rare, it might be that item is supposed to exist,
but there is some error while reading from storage - maybe the stored value is
serialized in a way we didn't expect, and deserialization fails. This is actually
a real thing that happened in one of the contracts I worked on in the past - we
changed the value type of the Map, and then forgot to migrate it, which caused
all sorts of problems.</p>
<h2 id="maps-as-sets"><a class="header" href="#maps-as-sets">Maps as sets</a></h2>
<p>So I imagine you can call me crazy right now - why do I spam about a <code>Map</code>, while
we are working with vector? It is clear that those two represent two distinct
things! Or do they?</p>
<p>Let's reconsider what we keep in the <code>ADMINS</code> vector - we have a list of objects
which we expect to be unique, which is a definition of a mathematical set. So
now let me bring back my initial definition of the map:</p>
<blockquote>
<p>First, let's define a map - in this context, it would be a <em>set</em> of keys with
values assigned to them, just like a HashMap in Rust or dictionaries in many languages.</p>
</blockquote>
<p>I purposely used the word &quot;set&quot; here - the map has the set built into it. It is
a generalization of a set or reversing the logic - the set is a particular case
of a map. If you imagine a set that map every single key to the same value, then
the values become irrelevant, and such a map becomes a set semantically.</p>
<p>How can you make a map mapping all the keys to the same value? We pick a type
with a single value. Typically in Rust, it would be a unit type (<code>()</code>), but in
CosmWasm, we tend to use the
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.Empty.html"><code>Empty</code></a>
type from CW standard crate:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Empty};
use cw_storage_plus::Map;

pub const ADMINS: Map&lt;Addr, Empty&gt; = Map::new(&quot;admins&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>We now need to fix the usage of the map in our contract. Let's start with contract
instantiation:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::msg::InstantiateMsg;
use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, admin, &amp;Empty {})?;
    }
    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;

    Ok(Response::new())
}
<span class="boring">}
</span></code></pre></pre>
<p>It didn't simplify much, but we no longer need to collect our address. Then
let's move to the leaving logic:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::ADMINS;
use cosmwasm_std::{DepsMut, MessageInfo};

pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
    ADMINS.remove(deps.storage, info.sender.clone());

    let resp = Response::new()
        .add_attribute(&quot;action&quot;, &quot;leave&quot;)
        .add_attribute(&quot;sender&quot;, info.sender.as_str());

    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we see a difference - we don't need to load a whole vector. We remove a
single entry with the
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.remove"><code>remove</code></a>
function.</p>
<p>What I didn't emphasize before, and what is relevant, is that <code>Map</code> stores every
single key as a distinct item. This way, accessing a single element will be
cheaper than using a vector.</p>
<p>However, this has its downside - accessing all the elements is more
gas-consuming using Map! In general, we tend to avoid such situations - the
linear complexity of the contract might lead to very expensive executions
(gas-wise) and potential vulnerabilities - if the user finds a way to create
many dummy elements in such a vector, he may make the execution cost exceeding
any gas limit.</p>
<p>Unfortunately, we have such an iteration in our contract - the distribution flow
becomes as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::error::ContractError;
use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    coins, BankMsg,DepsMut, MessageInfo, Order, Response
};

pub fn donate(deps: DepsMut, info: MessageInfo) -&gt; Result&lt;Response, ContractError&gt; {
    let denom = DONATION_DENOM.load(deps.storage)?;
    let admins: Result&lt;Vec&lt;_&gt;, _&gt; = ADMINS
        .keys(deps.storage, None, None, Order::Ascending)
        .collect();
    let admins = admins?;

    let donation = cw_utils::must_pay(&amp;info, &amp;denom)?.u128();

    let donation_per_admin = donation / (admins.len() as u128);

    let messages = admins.into_iter().map(|admin| BankMsg::Send {
        to_address: admin.to_string(),
        amount: coins(donation_per_admin, &amp;denom),
    });

    let resp = Response::new()
        .add_messages(messages)
        .add_attribute(&quot;action&quot;, &quot;donate&quot;)
        .add_attribute(&quot;amount&quot;, donation.to_string())
        .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());

    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<p>If I had to write a contract like this, and this <code>donate</code> would be a critical,
often called flow, I would advocate for going for an <code>Item&lt;Vec&lt;Addr&gt;&gt;</code> here.
Fortunately, it is not the case - the distribution does not have to be linear in
complexity! It might sound a bit crazy, as we have to iterate over all receivers
to distribute funds, but this is not true - there is a pretty nice way to do so
in constant time, which I will describe later in the book. For now, we will
leave it as it is, acknowledging the flaw of the contract, which we will fix later.</p>
<p>The final function to fix is the <code>admins_list</code> query handler:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::ADMINS;
use cosmwasm_std::{Deps, Order, StdResult};

pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
    let admins: Result&lt;Vec&lt;_&gt;, _&gt; = ADMINS
        .keys(deps.storage, None, None, Order::Ascending)
        .collect();
    let admins = admins?;
    let resp = AdminsListResp { admins };
    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we also have an issue with linear complexity, but it is far less of a problem.</p>
<p>First, queries are often purposed to be called on local nodes, with no gas cost -
we can query contracts as much as we want.</p>
<p>And then, even if we have some limit on execution time/cost, there is no reason to
query all the items every single time! We will fix this function later, adding
pagination - to limit the execution time/cost of the query caller would be able to
ask for a limited amount of items starting from the given one. Knowing this chapter,
you can probably figure implementation of it right now, but I will show the common
way we do that when I go through common CosmWasm practices.</p>
<h2 id="reference-keys"><a class="header" href="#reference-keys">Reference keys</a></h2>
<p>There is one subtlety to improve in our map usage.</p>
<p>The thing is that right now, we index the map with the owned Addr key. That forces
us to clone it if we want to reuse the key (particularly in the leave implementation).
This is not a huge cost, but we can avoid it - we can define the key of the map
to be a reference:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Empty};
use cw_storage_plus::Map;

pub const ADMINS: Map&lt;&amp;Addr, Empty&gt; = Map::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we need to fix the usages of the map in two places:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use crate::state::{ADMINS, DONATION_DENOM};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span>pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, &amp;admin, &amp;Empty {})?;
    }

    // ...

<span class="boring">   DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;
</span><span class="boring">
</span>   Ok(Response::new())
}

pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
    ADMINS.remove(deps.storage, &amp;info.sender);

    // ...

<span class="boring">   let resp = Response::new()
</span><span class="boring">       .add_attribute(&quot;action&quot;, &quot;leave&quot;)
</span><span class="boring">       .add_attribute(&quot;sender&quot;, info.sender.as_str());
</span><span class="boring">
</span>   Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../cross-contract/fixing-admin.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../cross-contract/working-with-time.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../cross-contract/fixing-admin.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../cross-contract/working-with-time.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
