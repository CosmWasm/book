<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CosmWasm book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guide to building CosmWasm smart contracts">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting started</li><li class="chapter-item expanded "><a href="setting-up-env.html"><strong aria-hidden="true">1.</strong> Setting up the environment</a></li><li class="chapter-item expanded "><a href="wasmd-quick-start.html"><strong aria-hidden="true">2.</strong> Quick start with wasmd</a></li><li class="chapter-item expanded affix "><li class="part-title">Smart contracts</li><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/rust-project.html"><strong aria-hidden="true">3.1.</strong> Create a Rust project</a></li><li class="chapter-item expanded "><a href="basics/entry-points.html"><strong aria-hidden="true">3.2.</strong> Entry points</a></li><li class="chapter-item expanded "><a href="basics/building-contract.html"><strong aria-hidden="true">3.3.</strong> Building the contract</a></li><li class="chapter-item expanded "><a href="basics/query.html"><strong aria-hidden="true">3.4.</strong> Creating a query</a></li><li class="chapter-item expanded "><a href="basics/query-testing.html"><strong aria-hidden="true">3.5.</strong> Testing a query</a></li><li class="chapter-item expanded "><a href="basics/multitest-intro.html"><strong aria-hidden="true">3.6.</strong> Introducing multitest</a></li><li class="chapter-item expanded "><a href="basics/state.html"><strong aria-hidden="true">3.7.</strong> Contract state</a></li><li class="chapter-item expanded "><a href="basics/execute.html"><strong aria-hidden="true">3.8.</strong> Execution messages</a></li><li class="chapter-item expanded "><a href="basics/events.html"><strong aria-hidden="true">3.9.</strong> Events, attributes and data</a></li><li class="chapter-item expanded "><a href="basics/funds.html"><strong aria-hidden="true">3.10.</strong> Dealing with funds</a></li><li class="chapter-item expanded "><a href="basics/good-practices.html"><strong aria-hidden="true">3.11.</strong> Good practices</a></li><li class="chapter-item expanded "><a href="basics/fp-types.html"><strong aria-hidden="true">3.12.</strong> Floating point types</a></li></ol></li><li class="chapter-item expanded "><a href="actor-model.html"><strong aria-hidden="true">4.</strong> The Actor Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="actor-model/idea.html"><strong aria-hidden="true">4.1.</strong> The idea</a></li><li class="chapter-item expanded "><a href="actor-model/actors-in-blockchain.html"><strong aria-hidden="true">4.2.</strong> Actors in the blockchain</a></li><li class="chapter-item expanded "><a href="actor-model/contract-as-actor.html"><strong aria-hidden="true">4.3.</strong> Contract as an actor</a></li></ol></li><li class="chapter-item expanded "><a href="cross-contract.html"><strong aria-hidden="true">5.</strong> Cross contract communication</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cross-contract/design.html"><strong aria-hidden="true">5.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="cross-contract/fixing-admin.html"><strong aria-hidden="true">5.2.</strong> Fixing admin contract</a></li><li class="chapter-item expanded "><a href="cross-contract/map-storage.html"><strong aria-hidden="true">5.3.</strong> Map storage</a></li><li class="chapter-item expanded "><a href="cross-contract/working-with-time.html"><strong aria-hidden="true">5.4.</strong> Working with time</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Inter-blockchain communication</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="impressum.html">Legal Information</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CosmWasm book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is a guide for creating CosmWasm smart contracts. It will lead you
step by step, and explain relevant topics from the easiest to the trickier
ones.</p>
<p>The idea of the book is not only to tell you about smart contracts API but also
to show you how to do it in a clean and maintainable way. We will show you
patterns that CosmWasm creators established and encouraged you to use.</p>
<h2 id="prerequirements"><a class="header" href="#prerequirements">Prerequirements</a></h2>
<p>This book explores CosmWasm smart contracts. It is not a Rust tutorial, and it
assumes basic Rust knowledge. As you will probably learn it alongside this
book, I strongly recommend grasping the language itself first. You can find
great resources to start with Rust on <a href="https://www.rust-lang.org/learn">Learn
Rust</a> page.</p>
<h2 id="cosmwasm-api-documentation"><a class="header" href="#cosmwasm-api-documentation">CosmWasm API documentation</a></h2>
<p>This is the guide-like documentation. If you are looking for the API
documentation, you may be interested in checking one of the following:</p>
<ul>
<li><a href="https://crates.io/crates/cosmwasm-std">cosmwasm-std</a></li>
<li><a href="https://crates.io/crates/cw-storage-plus">cw-storage-plus</a></li>
<li><a href="https://crates.io/crates/cw-multi-test">cw-multi-test</a></li>
<li><a href="https://crates.io/crates/cw-utils">cw-utils</a></li>
<li><a href="https://crates.io/crates/sylvia">sylvia framework</a></li>
</ul>
<h2 id="contributing-to-the-book"><a class="header" href="#contributing-to-the-book">Contributing to the book</a></h2>
<p>This book is maintained on <a href="https://github.com/CosmWasm/book">Github</a> and auto
deployed from there. Please create an
<a href="https://github.com/CosmWasm/book/issues">issue</a> or pull request if you find
any mistakes, bugs, or ambiguities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting up the environment</a></h1>
<p>To work with CosmWasm smart contract, you will need rust installed on your
machine. If you don't have one, you can find installation instructions on <a href="https://www.rust-lang.org/tools/install">the
Rust website</a>.</p>
<p>I assume you are working with a stable Rust channel in this book.</p>
<p>Additionally, you will need the Wasm rust compiler backend installed to build
Wasm binaries. To install it, run:</p>
<pre><code>rustup target add wasm32-unknown-unknown
</code></pre>
<p>Optionally if you want to try out your contracts on a testnet, you will need a
<a href="https://github.com/CosmWasm/wasmd">wasmd</a> binary. We would focus on testing
contracts with Rust unit testing utility throughout the book, so it is not
required to follow. However, seeing the product working in a real-world
environment may be nice.</p>
<p>To install <code>wasmd</code>, first install the <a href="https://github.com/golang/go/wiki#working-with-go">golang</a>. Then
clone the <code>wasmd</code> and install it:</p>
<pre><code>$ git clone git@github.com:CosmWasm/wasmd.git
$ cd ./wasmd
$ make install
</code></pre>
<p>Also, to be able to upload Rust Wasm Contracts into the blockchain, you will need
to install <a href="https://www.docker.com/">docker</a>. To minimize your contract sizes,
it will be required to run CosmWasm Rust Optimizer; without that, more complex
contracts might exceed a size limit.</p>
<h2 id="cosmwasm-check-utility"><a class="header" href="#cosmwasm-check-utility">cosmwasm-check utility</a></h2>
<p>An additional helpful tool for building smart contracts is the <code>cosmwasm-check</code><a href="https://github.com/CosmWasm/cosmwasm/tree/main/packages/check">utility</a>. It allows you to check if the wasm binary is a proper smart contract ready to upload into the blockchain. You can install it using cargo:</p>
<pre><code>$ cargo install cosmwasm-check
</code></pre>
<p>If the installation succeeds, you should be able to execute the utility from your command line.</p>
<pre><code>$ cosmwasm-check --version
Contract checking 1.2.3
</code></pre>
<h2 id="verifying-the-installation"><a class="header" href="#verifying-the-installation">Verifying the installation</a></h2>
<p>To guarantee you are ready to build your smart contracts, you need to make sure you can build examples.
Checkout the <a href="https://github.com/CosmWasm/cw-plus">cw-plus</a> repository and run the testing command in
its folder:</p>
<pre><code>$ git clone git@github.com:CosmWasm/cw-plus.git
$ cd ./cw-plus
cw-plus $ cargo test
</code></pre>
<p>You should see that everything in the repository gets compiled, and all tests pass. </p>
<p><code>cw-plus</code> is a great place to find example contracts - look for them in <code>contracts</code> directory. The
repository is maintained by CosmWasm creators, so contracts in there should follow good practices.</p>
<p>To verify the <code>cosmwasm-check</code> utility, first, you need to build a smart contract. Go to some contract directory, for example, <code>contracts/cw1-whitelist</code>, and call <code>cargo wasm</code>:</p>
<pre><code>cw-plus $ cd contracts/cw1-whitelist
cw-plus/contracts/cw1-whitelist $ cargo wasm
</code></pre>
<p>You should be able to find your output binary in the <code>target/wasm32-unknown-unknown/release/</code>
of the root repo directory - not in the contract directory itself! Now you can check if contract
validation passes:</p>
<pre><code>cw-plus/contracts/cw1-whitelist $ cosmwasm-check ../../target/wasm32-unknown-unknown/release/cw1_whitelist.wasm
Available capabilities: {&quot;iterator&quot;, &quot;cosmwasm_1_1&quot;, &quot;cosmwasm_1_2&quot;, &quot;stargate&quot;, &quot;staking&quot;}

../../target/wasm32-unknown-unknown/release/cw1_whitelist.wasm: pass

All contracts (1) passed checks!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-with-wasmd"><a class="header" href="#quick-start-with-wasmd">Quick start with <code>wasmd</code></a></h1>
<p>In the past, we suggested playing with contracts on the <code>malaga</code> testnet using <code>wasmd</code>.
Now <code>malaga</code> is no longer operative, and the best way to test the contract in the
real environment is to use one of the big CosmWasm chains testnets - Osmosis, Juno,
Terra, or other ones.
<a href="https://docs.osmosis.zone/cosmwasm/testnet/cosmwasm-deployment/">Here</a> is the
recommended introduction on how to start with the Osmosis testnet.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>In this chapter, we will go through creating basic smart contracts step by step.
I will try to explain the core ideas behind CosmWasm and the typical contract structure.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-rust-project"><a class="header" href="#create-a-rust-project">Create a Rust project</a></h1>
<p>As smart contracts are Rust library crates, we will start with creating one:</p>
<pre><code>$ cargo new --lib ./empty-contract
</code></pre>
<p>You created a simple Rust library, but it is not yet ready to be a smart contract. The first thing
to do is to update the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }

</code></pre>
<p>As you can see, I added a <code>crate-type</code> field for the library section. Generating the <code>cdylib</code> is
required to create a proper web assembly binary. The downside of this is that such a library cannot
be used as a dependency for other Rust crates - for now, it is not needed, but later we will show
how to approach reusing contracts as dependencies.</p>
<p>Additionally, there is one core dependency for smart contracts: the <code>cosmwasm-std</code>. This crate is a
standard library for smart contracts. It provides essential utilities for communication with the
outside world and a couple of helper functions and types. Every smart contract we will build will
use this dependency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entry-points"><a class="header" href="#entry-points">Entry points</a></h1>
<p>Typical Rust application starts with the <code>fn main()</code> function called by the operating system.
Smart contracts are not significantly different. When the message is sent to the contract, a
function called &quot;entry point&quot; is called. Unlike native applications, which have only a single
<code>main</code> entry point, smart contracts have a couple corresponding to different message types:
<code>instantiate</code>, <code>execute</code>, <code>query</code>, <code>sudo</code>, <code>migrate</code> and more.</p>
<p>To start, we will go with three basic entry points:</p>
<ul>
<li><code>instantiate</code> which is called once per smart contract lifetime - you can think about it as
a constructor or initializer of a contract.</li>
<li><code>execute</code> for handling messages which are able to modify contract state - they are used to
perform some actual actions.</li>
<li><code>query</code> for handling messages requesting some information from a contract; unlike <code>execute</code>,
they can never affect any contract state, and are used just like database queries.</li>
</ul>
<p>Go to your <code>src/lib.rs</code> file, and start with an <code>instantiate</code> entry point:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{
    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

#[entry_point]
pub fn instantiate(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty,
) -&gt; StdResult&lt;Response&gt; {
    Ok(Response::new())
}
</code></pre>
<p>In fact, <code>instantiate</code> is the only entry point required for a smart contract to be valid. It is not
very useful in this form, but it is a start. Let's take a closer look at the entry point structure.</p>
<p>First, we start with importing couple of types just for more consistent usage. Then we define our
entry point. The <code>instantiate</code> takes four arguments:</p>
<ul>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.DepsMut.html"><code>deps: DepsMut</code></a>
is a utility type for communicating with the outer world - it allows querying
and updating the contract state, querying other contracts state, and gives access to an <code>Api</code>
object with a couple of helper functions for dealing with CW addresses.</li>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Env.html"><code>env: Env</code></a>
is an object representing the blockchains state when executing the message - the
chain height and id, current timestamp, and the called contract address.</li>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.MessageInfo.html"><code>info: MessageInfo</code></a>
contains metainformation about the message which triggered an execution -
an address that sends the message, and chain native tokens sent with the message.</li>
<li><a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Empty.html"><code>msg: Empty</code></a>
is the message triggering execution itself - for now, it is <code>Empty</code> type that
represents <code>{}</code> JSON, but the type of this argument can be anything that is deserializable,
and we will pass more complex types here in the future.</li>
</ul>
<p>If you are new to the blockchain, those arguments may not have much sense to you, but while
progressing with this guide, I will explain their usage one by one.</p>
<p>Notice an essential attribute decorating our entry point
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/attr.entry_point.html"><code>#[entry_point]</code></a>. Its purpose is to
wrap the whole entry point to the form Wasm runtime understands. The proper Wasm entry points
can use only basic types supported natively by Wasm specification, and Rust structures and enums
are not in this set. Working with such entry points would be rather overcomplicated, so CosmWasm
creators delivered the <code>entry_point</code> macro. It creates the raw Wasm entry point, calling the
decorated function internally and doing all the magic required to build our high-level Rust arguments
from arguments passed by Wasm runtime.</p>
<p>The next thing to look at is the return type. I used
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/type.StdResult.html"><code>StdResult&lt;Response&gt;</code></a> for this simple example,
which is an alias for <code>Result&lt;Response, StdError&gt;</code>. The return entry point type would always be a
<a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> type, with some error type implementing
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> trait and a well-defined type for success
case. For most entry points, an &quot;Ok&quot; case would be the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html"><code>Response</code></a> type that allows fitting the contract
into our actor model, which we will discuss very soon.</p>
<p>The body of the entry point is as simple as it could be - it always succeeds with a trivial empty response.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-contract"><a class="header" href="#building-the-contract">Building the contract</a></h1>
<p>Now it is time to build our contract. We can use a traditional cargo build
pipeline for local testing purposes: <code>cargo build</code> for compiling it and <code>cargo test</code> for running all tests (which we don't have yet, but we will work on that
soon).</p>
<p>However, we need to create a wasm binary to upload the contract to blockchain.
We can do it by passing an additional argument to the build command:</p>
<pre><code>$ cargo build --target wasm32-unknown-unknown --release
</code></pre>
<p>The <code>--target</code> argument tells cargo to perform cross-compilation for a given target instead of
building a native binary for an OS it is running on - in this case, <code>wasm32-unknown-unknown</code>,
which is a fancy name for Wasm target.</p>
<p>Additionally, I passed the <code>--release</code> argument to the command - it is not
required, but in most cases, debug information is not very useful while running
on-chain. It is crucial to reduce the uploaded binary size for gas cost
minimization. It is worth knowing that there is a <a href="https://github.com/CosmWasm/rust-optimizer">CosmWasm Rust
Optimizer</a> tool that takes care of
building even smaller binaries. For production, all the contracts should be
compiled using this tool, but for learning purposes, it is not an essential
thing to do.</p>
<h2 id="aliasing-build-command"><a class="header" href="#aliasing-build-command">Aliasing build command</a></h2>
<p>Now I can see you are disappointed in building your contracts with some overcomplicated command
instead of simple <code>cargo build</code>. Fortunately, it is not the case. The common practice is to alias
the building command to make it as simple as building a native app.</p>
<p>Let's create the <code>.cargo/config</code> file in your contract project directory with the following content:</p>
<pre><code class="language-toml">[alias]
wasm = &quot;build --target wasm32-unknown-unknown --release&quot;
wasm-debug = &quot;build --target wasm32-unknown-unknown&quot;
</code></pre>
<p>Now, building your Wasm binary is as easy as executing <code>cargo wasm</code>. We also added the additional
<code>wasm-debug</code> command for rare cases when we want to build the wasm binary, including debug information.</p>
<h2 id="checking-contract-validity"><a class="header" href="#checking-contract-validity">Checking contract validity</a></h2>
<p>When the contract is built, the last step is to ensure it is a valid CosmWasm contract is to call
<code>cosmwasm-check</code> on it:</p>
<pre><code>$ cargo wasm
...
$ cosmwasm-check ./target/wasm32-unknown-unknown/release/contract.wasm
Available capabilities: {&quot;cosmwasm_1_1&quot;, &quot;staking&quot;, &quot;stargate&quot;, &quot;iterator&quot;, &quot;cosmwasm_1_2&quot;}

./target/wasm32-unknown-unknown/release/contract.wasm: pass
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-query"><a class="header" href="#creating-a-query">Creating a query</a></h1>
<p>We have already created a simple contract reacting to an empty instantiate message. Unfortunately, it
is not very useful. Let's make it a bit reactive.</p>
<p>First, we need to add <a href="https://crates.io/crates/serde"><code>serde</code></a> crate to our dependencies. It would help us with the serialization and
deserialization of query messages. Update the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>Now go to your <code>src/lib.rs</code> file, and add a new query entry point:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{
    entry_point, to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo,
    Response, StdResult,
};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
struct QueryResp {
    message: String,
}

<span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn query(_deps: Deps, _env: Env, _msg: Empty) -&gt; StdResult&lt;Binary&gt; {
    let resp = QueryResp {
        message: &quot;Hello World&quot;.to_owned(),
    };

    to_binary(&amp;resp)
}
</code></pre>
<p>Note that I omitted the previously created instantiate endpoint for simplicity -
not to overload you with code, I will always only show lines that changed in the code.</p>
<p>We first need a structure we will return from our query. We always want to return something
which is serializable. We are just deriving the
<a href="https://docs.serde.rs/serde/trait.Serialize.html"><code>Serialize</code></a> and
<a href="https://docs.serde.rs/serde/trait.Deserialize.html"><code>Deserialize</code></a> traits from <code>serde</code> crate.</p>
<p>Then we need to implement our entry point. It is very similar to the <code>instantiate</code> one. The
first significant difference is a type of <code>deps</code> argument. For <code>instantiate</code>, it was a <code>DepMut</code>,
but here we went with a <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Deps.html"><code>Deps</code></a>
object. That is because the query can never alter the smart
contract's internal state. It can only read the state. It comes with some consequences - for example,
it is impossible to implement caching for future queries (as it would require some data cache to write
to).</p>
<p>The other difference is the lack of the <code>info</code> argument. The reason here is that the entry point which
performs actions (like instantiation or execution) can differ how an action is performed based on the
message metadata - for example, they can limit who can perform an action (and do so by checking the
message <code>sender</code>). It is not a case for queries. Queries are supposed just purely to return some
transformed contract state. It can be calculated based on some chain metadata (so the state can
&quot;automatically&quot; change after some time), but not on message info.</p>
<p>Note that our entry point still has the same <code>Empty</code> type for its <code>msg</code> argument - it means that the
query message we would send to the contract is still an empty JSON: <code>{}</code></p>
<p>The last thing that changed is the return type. Instead of returning the <code>Response</code> type on the success
case, we return an arbitrary serializable object. This is because queries are not using a typical actor
model message flow - they cannot trigger any actions nor communicate with other contracts in ways different
than querying them (which is handled by the <code>deps</code> argument). The query always returns plain data, which
should be presented directly to the querier.</p>
<p>Now take a look at the implementation. Nothing complicated happens there - we create an object we want
to return and encode it to the <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Binary.html"><code>Binary</code></a>
type using the <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/fn.to_binary.html"><code>to_binary</code></a> function.</p>
<h2 id="improving-the-message"><a class="header" href="#improving-the-message">Improving the message</a></h2>
<p>We have a query, but there is a problem with the query message. It is always an empty JSON. It is terrible -
if we would like to add another query in the future, it would be difficult to have any reasonable distinction
between query variants.</p>
<p>In practice, we address this by using a non-empty query message type. Improve our contract:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{
</span><span class="boring">    entry_point, to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize)]
</span><span class="boring">struct QueryResp {
</span><span class="boring">    message: String,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
pub enum QueryMsg {
    Greet {},
}

<span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; {
            let resp = QueryResp {
                message: &quot;Hello World&quot;.to_owned(),
            };

            to_binary(&amp;resp)
        }
    }
}
</code></pre>
<p>Now we introduced a proper message type for the query message. It is an
<a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">enum</a>, and by
default, it would serialize to a JSON with a single field - the name of the field
will be an enum variant (in our case - always &quot;greet&quot; - at least for now), and the
value of this field would be an object assigned to this enum variant.</p>
<p>Note that our enum has no type assigned to the only <code>Greet</code> variant. Typically
in Rust, we create such variants without additional <code>{}</code> after the variant name. Here the
curly braces have a purpose - without them, the variant would serialize to just a string
type - so instead of <code>{ &quot;greet&quot;: {} }</code>, the JSON representation of this variant would be
<code>&quot;greet&quot;</code>. This behavior brings inconsistency in the message schema. It is, generally,
a good habit to always add the <code>{}</code> to serde serializable empty enum variants - for better
JSON representation.</p>
<p>But now, we can still improve the code further. Right now, the <code>query</code> function has two
responsibilities. The first is obvious - handling the query itself. It was the first
assumption, and it is still there. But there is a new thing happening there - the query
message dispatching. It may not be obvious, as there is a single variant, but the query
function is an excellent way to become a massive unreadable <code>match</code> statement. To make
the code more <a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a>, we will refactor it and
take out handling the <code>greet</code> message to a
separate function.</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{
</span><span class="boring">    entry_point, to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize)]
pub struct GreetResp {
    message: String,
}

<span class="boring">#[derive(Serialize, Deserialize)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; to_binary(&amp;query::greet()?),
    }
}

mod query {
    use super::*;

    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
        let resp = GreetResp {
            message: &quot;Hello World&quot;.to_owned(),
        };

        Ok(resp)
    }
}
</code></pre>
<p>Now it looks much better. Note there are a couple of additional improvements. I
renamed the query-response type <code>GreetResp</code> as I may have different responses
for different queries. I want the name to relate only to the variant, not the
whole message.</p>
<p>Next is enclosing my new function in the module <code>query</code>. It makes it easier to
avoid name collisions - I can have the same variant for queries and execution
messages in the future, and their handlers would lie in separate namespaces.</p>
<p>A questionable decision may be returning <code>StdResult</code> instead of <code>GreetResp</code>
from <code>greet</code> function, as it would never return an error. It is a matter of
style, but I prefer consistency over the message handler, and the majority of
them would have failure cases - e.g. when reading the state.</p>
<p>Also, you might pass <code>deps</code> and <code>env</code> arguments to all your query handlers for
consistency. I'm not too fond of this, as it introduces unnecessary boilerplate
which doesn't read well, but I also agree with the consistency argument - I
leave it to your judgment.</p>
<h2 id="structuring-the-contract"><a class="header" href="#structuring-the-contract">Structuring the contract</a></h2>
<p>You can see that our contract is becoming a bit bigger now. About 50 lines are maybe
not so much, but there are many different entities in a single file, and I think we
can do better. I can already distinguish three different types of entities in the code:
entry points, messages, and handlers. In most contracts, we would divide them across
three files. Start with extracting all the messages to <code>src/msg.rs</code>:</p>
<pre><code class="language-rust noplayground">use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize)]
pub enum QueryMsg {
    Greet {},
}
</code></pre>
<p>You probably noticed that I made my <code>GreetResp</code> fields public. It is because they have
to be now accessed from a different module. Now move forward to the <code>src/contract.rs</code> file:</p>
<pre><code class="language-rust noplayground">use crate::msg::{GreetResp, QueryMsg};
use cosmwasm_std::{
    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

pub fn instantiate(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty,
) -&gt; StdResult&lt;Response&gt; {
    Ok(Response::new())
}

pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; to_binary(&amp;query::greet()?),
    }
}

mod query {
    use super::*;

    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
        let resp = GreetResp {
            message: &quot;Hello World&quot;.to_owned(),
        };

        Ok(resp)
    }
}
</code></pre>
<p>I moved most of the logic here, so my <code>src/lib.rs</code> is just a very thin library entry with nothing
else but module definitions and entry points definition. I removed the <code>#[entry_point]</code> attribute
from my <code>query</code> function in <code>src/contract.rs</code>. I will have a function with this attribute.
Still, I wanted to split functions' responsibility further - not the <code>contract::query</code> function is
the top-level query handler responsible for dispatching the query message. The <code>query</code> function on
crate-level is only an entry point. It is a subtle distinction, but it will make sense in the future
when we would like not to generate the entry points but to keep the dispatching functions. I introduced
the split now to show you the typical contract structure.</p>
<p>Now the last part, the <code>src/lib.rs</code> file:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{
    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

mod contract;
mod msg;

#[entry_point]
pub fn instantiate(deps: DepsMut, env: Env, info: MessageInfo, msg: Empty)
  -&gt; StdResult&lt;Response&gt;
{
    contract::instantiate(deps, env, info, msg)
}

#[entry_point]
pub fn query(deps: Deps, env: Env, msg: msg::QueryMsg)
  -&gt; StdResult&lt;Binary&gt;
{
    contract::query(deps, env, msg)
}
</code></pre>
<p>Straightforward top-level module. Definition of submodules and entry points, nothing more.</p>
<p>Now, when we have the contract ready to do something, let's go and test it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-a-query"><a class="header" href="#testing-a-query">Testing a query</a></h1>
<p>Last time we created a new query, now it is time to test it out. We will start with the basics -
the unit test. This approach is simple and doesn't require knowledge besides Rust. Go to the
<code>src/contract.rs</code> and add a test in its module:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, QueryMsg};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greet_query() {
        let resp = query::greet().unwrap();
        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}
</code></pre>
<p>If you ever wrote a unit test in Rust, nothing should surprise you here. Just a
simple test-only module contains local function unit tests. The problem is - this
test doesn't build yet. We need to tweak our message types a bit. Update the <code>src/msg.rs</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum QueryMsg {
    Greet {},
}
</code></pre>
<p>I added three new derives to both message types. <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>
is required to allow comparing types
for equality - so we can check if they are equal. The <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>
is a trait generating debug-printing
utilities. It is used by <a href="https://doc.rust-lang.org/std/macro.assert_eq.html"><code>assert_eq!</code></a> to
display information about mismatch if an assertion
fails. Note that because we are not testing the <code>QueryMsg</code> in any way, the additional trait derives
are optional. Still, it is a good practice to make all messages both <code>PartialEq</code> and <code>Debug</code> for
testability and consistency.
The last one, <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> is not needed for now yet,
but it is also good practice to allow messages to be cloned around. We will also require that
later, so I added it already not to go back and forth.</p>
<p>Now we are ready to run our test:</p>
<pre><code>$ cargo test

...
running 1 test
test contract::tests::greet_query ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>Yay! Test passed!</p>
<h2 id="contract-as-a-black-box"><a class="header" href="#contract-as-a-black-box">Contract as a black box</a></h2>
<p>Now let's go a step further. The Rust testing utility is a friendly tool for building even higher-level
tests. We are currently testing smart contract internals, but if you think about how your smart contract
is visible from the outside world. It is a single entity that is triggered by some input messages. We can
create tests that treat the whole contract as a black box by testing it via our <code>query</code> function. Let's
update our test:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, QueryMsg};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use cosmwasm_std::from_binary;
    use cosmwasm_std::testing::{mock_dependencies, mock_env};

    use super::*;

    #[test]
    fn greet_query() {
        let resp = query(
            mock_dependencies().as_ref(),
            mock_env(),
            QueryMsg::Greet {}
        ).unwrap();
        let resp: GreetResp = from_binary(&amp;resp).unwrap();

        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}
</code></pre>
<p>We needed to produce two entities for the <code>query</code> functions: the <code>deps</code> and <code>env</code> instances.
Fortunately, <code>cosmwasm-std</code> provides utilities for testing those -
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/testing/fn.mock_dependencies.html"><code>mock_dependencies</code></a>
and <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/testing/fn.mock_env.html"><code>mock_env</code></a>
functions.</p>
<p>You may notice the dependencies mock of a type
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.OwnedDeps.html"><code>OwnedDeps</code></a> instead
of <code>Deps</code>, which we need here - this is why the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.OwnedDeps.html#method.as_ref"><code>as_ref</code></a>
function is called on it. If we looked for a <code>DepsMut</code> object, we would use
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.OwnedDeps.html#method.as_mut"><code>as_mut</code></a>
instead.</p>
<p>We can rerun the test, and it should still pass. But when we think about that test reflecting
the actual use case, it is inaccurate. The contract is queried, but it was never instantiated!
In software engineering, it is equivalent to calling a getter without constructing an object -
taking it out of nowhere. It is a lousy testing approach. We can do better:</p>
<pre><code class="language-rust noplayground">
<span class="boring">use crate::msg::{GreetResp, QueryMsg};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use cosmwasm_std::from_binary;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};

    use super::*;

    #[test]
    fn greet_query() {
        let mut deps = mock_dependencies();
        let env = mock_env();

        instantiate(
            deps.as_mut(),
            env.clone(),
            mock_info(&quot;sender&quot;, &amp;[]),
            Empty {},
        )
        .unwrap();

        let resp = query(deps.as_ref(), env, QueryMsg::Greet {}).unwrap();
        let resp: GreetResp = from_binary(&amp;resp).unwrap();
        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}
</code></pre>
<p>A couple of new things here. First, I extracted the <code>deps</code> and <code>env</code> variables to their variables
and passed them to calls. The idea is that those variables represent some blockchain persistent state,
and we don't want to create them for every call. We want any changes to the contract state occurring
in <code>instantiate</code> to be visible in the <code>query</code>. Also, we want to control how the environment differs
on the query and instantiation.</p>
<p>The <code>info</code> argument is another story. The message info is unique for each message sent. To create the
<code>info</code> mock, we must pass two arguments to the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/testing/fn.mock_info.html"><code>mock_info</code></a> function.</p>
<p>First is the address performing a call. It may look strange to pass <code>sender</code> as an address instead of some
mysterious <code>wasm</code> followed by hash, but it is a valid address. For testing purposes, such addresses are
typically better, as they are way more verbose in case of failing tests.</p>
<p>The second argument is funds sent with the message. For now, we leave it as an empty slice, as I don't want
to talk about token transfers yet - we will cover it later.</p>
<p>So now it is more a real-case scenario. I see just one problem. I say that the contract is a single black
box. But here, nothing connects the <code>instantiate</code> call to the corresponding <code>query</code>. It seems that we assume
there is some global contract. But it seems that if we would like to have two contracts instantiated differently
in a single test case, it would become a mess. If only there would be some tool to abstract this for us, wouldn't
it be nice?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-multitest"><a class="header" href="#introducing-multitest">Introducing multitest</a></h1>
<p>Let me introduce the <a href="https://crates.io/crates/cw-multi-test"><code>multitest</code></a> -
library for creating tests for smart contracts in Rust.</p>
<p>The core idea of <code>multitest</code> is abstracting an entity of contract and
simulating the blockchain environment for testing purposes. The purpose of this
is to be able to test communication between smart contracts. It does its job
well, but it is also an excellent tool for testing single-contract scenarios.</p>
<p>First, we need to add a multitest to our <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>I added a new
<a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a>
section with dependencies not used by the final binary
but which may be used by tools around the development process - for example, tests.</p>
<p>When we have the dependency ready, update our test to use the framework:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, QueryMsg};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    _deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    _msg: Empty,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[allow(dead_code)]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: Empty
) -&gt; StdResult&lt;Response&gt; {
    unimplemented!()
}

<span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use cosmwasm_std::Addr;
    use cw_multi_test::{App, ContractWrapper, Executor};

    use super::*;

    #[test]
    fn greet_query() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;Empty {},
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp: GreetResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
            .unwrap();

        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
}
</code></pre>
<p>You probably notice that I added the function for an <code>execute</code> entry point. I didn't add the entry point
itself or the function's implementation, but for the multitest purposes contract has to contain at least
instantiate, query, and execute handlers. I attributed the function as
<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#lint-check-attributes"><code>#[allow(dead_code)]</code></a>,
so, <code>cargo</code> will not complain about it not being used anywhere. Enabling it for tests only with <code>#[cfg(test)]</code>
would also be a way.</p>
<p>Then at the beginning of the test, I created the
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html#"><code>App</code></a>
object. It is a core multitest entity representing the virtual blockchain on
which we will run our contracts. As you can see, we can call functions on it
just like we would interact with blockchain using <code>wasmd</code>!</p>
<p>Right after creating <code>app</code>, I prepared the representation of the <code>code</code>, which
would be &quot;uploaded&quot; to the blockchain. As multitests are just native Rust
tests, they do not involve any Wasm binaries, but this name matches well what
happens in a real-life scenario. We store this object in the blockchain with
the <a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html#method.store_code"><code>store_code</code></a>
function, and as a result, we are getting the code id - we would need it to
instantiate a contract.</p>
<p>Instantiation is the next step. In a single
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/trait.Executor.html#method.instantiate_contract"><code>instantiate_contract</code></a>
call, we provide everything we would provide via <code>wasmd</code> - the contract code id, the address which performs instantiation,</p>
<p>the message triggering it, and any funds sent with the message (again - empty for now). We are adding the contract label
and its admin for migrations - <code>None</code>, as we don't need it yet.</p>
<p>And after the contract is online, we can query it. The
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html?search=in#method.wrap"><code>wrap</code></a> function is an accessor
for querying Api (queries are handled a bit differently than other calls), and the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.QuerierWrapper.html#method.query_wasm_smart"><code>query_wasm_smart</code></a>
queries are given a contract with the message. Also, we don't need to care about query results as <code>Binary</code> - multitest
assumes that we would like to deserialize them to some response type, so it takes advantage of Rust type elision to
provide us with a nice Api.</p>
<p>Now it's time to rerun the test. It should still pass, but now we nicely abstracted the testing contract as a whole,
not some internal functions. The next thing we should probably cover is making the contract more interesting
by adding some state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-state"><a class="header" href="#contract-state">Contract state</a></h1>
<p>The contract we are working on already has some behavior that can answer a query. Unfortunately, it is
very predictable with its answers, and it has nothing to alter them. In this chapter, I introduce the
notion of state, which would allow us to bring true life to a smart contract.</p>
<p>The state would still be static for now - it would be initialized on contract instantiation. The state
would contain a list of admins who would be eligible to execute messages in the future.</p>
<p>The first thing to do is to update <code>Cargo.toml</code> with yet another dependency - the
<a href="https://crates.io/crates/cw-storage-plus"><code>storage-plus</code></a> crate with high-level bindings for CosmWasm
smart contracts state management:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.13.4&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>Now create a new file where you will keep a state for the contract - we typically call it <code>src/state.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use cw_storage_plus::Item;

pub const ADMINS: Item&lt;Vec&lt;Addr&gt;&gt; = Item::new(&quot;admins&quot;);
</code></pre>
<p>And make sure we declare the module in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{
</span><span class="boring">    entry_point, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">mod contract;
</span><span class="boring">mod msg;
</span>mod state;
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(deps: DepsMut, env: Env, info: MessageInfo, msg: Empty)
</span><span class="boring">  -&gt; StdResult&lt;Response&gt;
</span><span class="boring">{
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: msg::QueryMsg)
</span><span class="boring">  -&gt; StdResult&lt;Binary&gt;
</span><span class="boring">{
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}
</span></code></pre>
<p>The new thing we have here is the <code>ADMINS</code> constant of type <code>Item&lt;Vec&lt;Addr&gt;&gt;</code>. You could ask an excellent
question here - how is the state constant? How do I modify it if it is a constant value?</p>
<p>The answer is tricky - this constant is not keeping the state itself. The state is stored in the
blockchain and is accessed via the <code>deps</code> argument passed to entry points. The storage-plus constants
are just accessor utilities helping us access this state in a structured way.</p>
<p>In CosmWasm, the blockchain state is just massive key-value storage. The keys are prefixed with metainformation
pointing to the contract which owns them (so no other contract can alter them in any way), but even after
removing the prefixes, the single contract state is a smaller key-value pair.</p>
<p><code>storage-plus</code> handles more complex state structures by additionally prefixing items keys intelligently. For now,
we just used the simplest storage entity - an
<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html"><code>Item&lt;_&gt;</code></a>, which holds a single optional
value of a given type -
<code>Vec&lt;Addr&gt;</code> in this case. And what would be a key to this item in the storage? It doesn't matter to us - it would
be figured out to be unique, based on a unique string passed to the
<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.new"><code>new</code></a> function.</p>
<p>Before we would go into initializing our state, we need some better instantiate message. Go to <code>src/msg.rs</code> and create one:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
}
<span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">}
</span></code></pre>
<p>Now go forward to instantiate the entry point in <code>src/contract.rs</code>, and initialize our state to whatever we got in the instantiation message:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, InstantiateMsg, QueryMsg};
</span>use crate::state::ADMINS;
// --snip--
<span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span>pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
        .admins
        .into_iter()
        .map(|addr| deps.api.addr_validate(&amp;addr))
        .collect();
    ADMINS.save(deps.storage, &amp;admins?)?;

    Ok(Response::new())
}
<span class="boring">
</span><span class="boring">pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;Empty {},
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>We also need to update the message type on entry point in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span>use msg::InstantiateMsg;
// --snip--
<span class="boring">
</span><span class="boring">mod contract;
</span><span class="boring">mod msg;
</span><span class="boring">mod state;
</span><span class="boring">
</span>#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    contract::instantiate(deps, env, info, msg)
}
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: msg::QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}
</span></code></pre>
<p>Voila, that's all that is needed to update the state!</p>
<p>First, we need to transform the vector of strings into the vector of addresses to be stored. We cannot take
addresses as a message argument because not every string is a valid address. It might be a bit confusing when
we were working on tests. Any string could be used in the place of address. Let me explain.</p>
<p>Every string can be technically considered an address. However, not every string is an actual existing blockchain
address. When we keep anything of type <code>Addr</code> in the contract, we assume it is a proper address in the blockchain.
That is why the <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/trait.Api.html#tymethod.addr_validate"><code>addr_validate</code></a>
function exits - to check this precondition.</p>
<p>Having data to store, we use the <a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.save"><code>save</code></a>
function to write it into the contract state. Note that the first argument of <code>save</code> is
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/trait.Storage.html"><code>&amp;mut Storage</code></a>, which is actual blockchain
storage. As emphasized, the <code>Item</code> object stores nothing and is just an accessor. It determines how to store the data
in the storage given to it. The second argument is the serializable data to be stored.</p>
<p>It is a good time to check if the regression we have passes - try running our tests:</p>
<pre><code>&gt; cargo test

...

running 1 test
test contract::tests::greet_query ... FAILED

failures:

---- contract::tests::greet_query stdout ----
thread 'contract::tests::greet_query' panicked at 'called `Result::unwrap()` on an `Err` value: error executing WasmMsg:
sender: owner
Instantiate { admin: None, code_id: 1, msg: Binary(7b7d), funds: [], label: &quot;Contract&quot; }

Caused by:
    Error parsing into type contract::msg::InstantiateMsg: missing field `admins`', src/contract.rs:80:14
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    contract::tests::greet_query

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Damn, we broke something! But be calm. Let's start with carefully reading an error message:</p>
<blockquote>
<p>Error parsing into type contract::msg::InstantiateMsg: missing field <code>admins</code>', src/contract.rs:80:14</p>
</blockquote>
<p>The problem is that in the test, we send an empty instantiation message in our test, but right now, our endpoint expects
to have an <code>admin</code> field. Multi-test framework tests contract from the entry point to results, so sending messages using MT
functions first serializes them. Then the contract deserializes them on the entry. But now it tries to deserialize the
empty JSON to some non-empty message! We can quickly fix it by updating the test:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::msg::{GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greet_query() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg { admins: vec![] },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp: GreetResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
            .unwrap();

        assert_eq!(
            resp,
            GreetResp {
                message: &quot;Hello World&quot;.to_owned()
            }
        );
    }
<span class="boring">}
</span></code></pre>
<h2 id="testing-state"><a class="header" href="#testing-state">Testing state</a></h2>
<p>When the state is initialized, we want a way to test it. We want to provide a
query to check if the instantiation affects the state. Just create a simple one
listing all admins. Start with adding a variant for query message and a corresponding response message in <code>src/msg.rs</code>. We'll call the variant <code>AdminsList</code>, the response <code>AdminsListResp</code>, and have it return a vector of <code>cosmwasm_std::Addr</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct AdminsListResp  {
    pub admins: Vec&lt;Addr&gt;,
}

[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}
</code></pre>
<p>And implement it in <code>src/contract.rs</code>:</p>
<pre><code class="language-rust noplayground">use crate::msg::{AdminsListResp, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span>pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        Greet {} =&gt; to_binary(&amp;query::greet()?),
        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
    }
}
 
<span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span>mod query {
<span class="boring">   use super::*;
</span><span class="boring">
</span><span class="boring">   pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">       let resp = GreetResp {
</span><span class="boring">           message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">       };
</span><span class="boring">
</span><span class="boring">       Ok(resp)
</span><span class="boring">   }
</span><span class="boring">
</span>    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
        let admins = ADMINS.load(deps.storage)?;
        let resp = AdminsListResp { admins };
        Ok(resp)
    }
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">       let mut app = App::default();
</span><span class="boring">
</span><span class="boring">       let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">       let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">       let addr = app
</span><span class="boring">           .instantiate_contract(
</span><span class="boring">               code_id,
</span><span class="boring">               Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">               &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">               &amp;[],
</span><span class="boring">               &quot;Contract&quot;,
</span><span class="boring">               None,
</span><span class="boring">           )
</span><span class="boring">           .unwrap();
</span><span class="boring">
</span><span class="boring">       let resp: GreetResp = app
</span><span class="boring">           .wrap()
</span><span class="boring">           .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">           .unwrap();
</span><span class="boring">
</span><span class="boring">       assert_eq!(
</span><span class="boring">           resp,
</span><span class="boring">           GreetResp {
</span><span class="boring">               message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">           }
</span><span class="boring">       );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Now when we have the tools to test the instantiation, let's write a test case:</p>
<pre><code class="language-rust noplayground">use crate::msg::{AdminsListResp, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">pub fn execute(_deps: DepsMut, _env: Env, _info: MessageInfo, _msg: Empty) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn instantiation() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg { admins: vec![] },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp: AdminsListResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
            .unwrap();

        assert_eq!(resp, AdminsListResp { admins: vec![] });

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg {
                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
                },
                &amp;[],
                &quot;Contract 2&quot;,
                None,
            )
            .unwrap();

        let resp: AdminsListResp = app
            .wrap()
            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
            .unwrap();

        assert_eq!(
            resp,
            AdminsListResp {
                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
            }
        );
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span>}
</code></pre>
<p>The test is simple - instantiate the contract twice with different initial admins, and ensure the query result
is proper each time. This is often the way we test our contract - we execute bunch o messages on the contract,
and then we query it for some data, verifying if query responses are like expected.</p>
<p>We are doing a pretty good job developing our contract. Now it is time to use the state and allow for some executions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-messages"><a class="header" href="#execution-messages">Execution messages</a></h1>
<p>We went through instantiate and query messages. It is finally time to introduce the last basic entry point -
the execute messages. It is similar to what we have done so far that I expect this to be just chilling and
revisiting our knowledge. I encourage you to try implementing what I am describing here on your own as an
exercise - without checking out the source code.</p>
<p>The idea of the contract will be easy - every contract admin would be eligible to call two execute messages:</p>
<ul>
<li><code>AddMembers</code> message would allow the admin to add another address to the admin's list</li>
<li><code>Leave</code> would allow and admin to remove himself from the list</li>
</ul>
<p>Not too complicated. Let's go coding. Start with defining messages:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
}
<span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">    AdminsList {},
</span><span class="boring">}
</span></code></pre>
<p>And implement entry point:</p>
<pre><code class="language-rust noplayground">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span> 
#[allow(dead_code)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; StdResult&lt;Response&gt; {
    use ExecuteMsg::*;

    match msg {
        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
        Leave {} =&gt; exec::leave(deps, info),
    }
}

mod exec {
    use cosmwasm_std::StdError;

    use super::*;

    pub fn add_members(
        deps: DepsMut,
        info: MessageInfo,
        admins: Vec&lt;String&gt;,
    ) -&gt; StdResult&lt;Response&gt; {
        let mut curr_admins = ADMINS.load(deps.storage)?;
        if !curr_admins.contains(&amp;info.sender) {
            return Err(StdError::generic_err(&quot;Unauthorised access&quot;));
        }

        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
            .into_iter()
            .map(|addr| deps.api.addr_validate(&amp;addr))
            .collect();

        curr_admins.append(&amp;mut admins?);
        ADMINS.save(deps.storage, &amp;curr_admins)?;

        Ok(Response::new())
    }

    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
            let admins = admins
                .into_iter()
                .filter(|admin| *admin != info.sender)
                .collect();
            Ok(admins)
        })?;

        Ok(Response::new())
    }
}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The entry point itself also has to be created in <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};

mod contract;
mod msg;
mod state;

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    contract::instantiate(deps, env, info, msg)
}

#[entry_point]
pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -&gt; StdResult&lt;Response&gt; {
    contract::execute(deps, env, info, msg)
}

#[entry_point]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    contract::query(deps, env, msg)
}
</code></pre>
<p>There are a couple of new things, but nothing significant. First is how do I reach the message sender
to verify he is an admin or remove him from the list - I used the <code>info.sender</code> field of <code>MessageInfo</code>,
which is how it looks like - the member. As the message is always sent from the proper address, the
<code>sender</code> is already of the <code>Addr</code> type - no need to validate it. Another new thing is the
<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.update"><code>update</code></a>
function on an <code>Item</code> - it makes a read and update of an entity potentially more efficient. It is
possible to do it by reading admins first, then updating and storing the result.</p>
<p>You probably noticed that when working with <code>Item</code>, we always assume something
is there. But nothing forces us to initialize the <code>ADMINS</code> value on
instantiation! So what happens there? Well, both <code>load</code> and <code>update</code> functions
would return an error. But there is a
<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.may_load"><code>may_load</code></a>
function, which returns <code>StdResult&lt;Option&lt;T&gt;&gt;</code> - it would return <code>Ok(None)</code> in
case of empty storage. There is even a possibility to remove an existing item
from storage with the
<a href="https://docs.rs/cw-storage-plus/0.13.4/cw_storage_plus/struct.Item.html#method.remove"><code>remove</code></a>
function.</p>
<p>One thing to improve is error handling. While validating the sender to be admin, we are returning
some arbitrary string as an error. We can do better.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h2>
<p>In our contract, we now have an error situation when a user tries to execute <code>AddMembers</code> not being
an admin himself. There is no proper error case in
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/enum.StdError.html"><code>StdError</code></a> to report this
situation, so we have to return a generic error with a message. It is not the best approach.</p>
<p>For error reporting, we encourage using <a href="https://crates.io/crates/thiserror/1.0.24/dependencies"><code>thiserror</code></a>
crate. Start with updating your dependencies:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.13.4&quot;
thiserror = &quot;1&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>Now we define an error type in <code>src/error.rs</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdError};
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error(&quot;{0}&quot;)]
    StdError(#[from] StdError),
    #[error(&quot;{sender} is not contract admin&quot;)]
    Unauthorized { sender: Addr },
}
</code></pre>
<p>We also need to add the new module to <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span><span class="boring">
</span>mod contract;
mod error;
mod msg;
mod state;
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::execute(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}
</span></code></pre>
<p>Using <code>thiserror</code> we define errors like a simple enum, and the crate ensures
that the type implements
<a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>
trait. A very nice feature of this crate is the inline definition of
<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> trait by an
<code>#[error]</code> attribute. Also, another helpful thing is the <code>#[from]</code> attribute,
which automatically generates proper
<a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> implementation,
so it is easy to use <code>?</code> operator with <code>thiserror</code> types.</p>
<p>Now update the execute endpoint to use our new error type:</p>
<pre><code class="language-rust noplayground">use crate::error::ContractError;
use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
<span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span> 
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    use ExecuteMsg::*;

    match msg {
        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
    }
}

mod exec {
    use super::*;

    pub fn add_members(
        deps: DepsMut,
        info: MessageInfo,
        admins: Vec&lt;String&gt;,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let mut curr_admins = ADMINS.load(deps.storage)?;
        if !curr_admins.contains(&amp;info.sender) {
            return Err(ContractError::Unauthorized {
                sender: info.sender,
            });
        }

        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
            .into_iter()
            .map(|addr| deps.api.addr_validate(&amp;addr))
            .collect();

        curr_admins.append(&amp;mut admins?);
        ADMINS.save(deps.storage, &amp;curr_admins)?;

        Ok(Response::new())
    }
<span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>The entry point return type also has to be updated:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span>use error::ContractError;
<span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span>
<span class="boring">mod contract;
</span><span class="boring">mod error;
</span><span class="boring">mod msg;
</span><span class="boring">mod state;
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span>#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    contract::execute(deps, env, info, msg)
}
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}
</span></code></pre>
<h2 id="custom-error-and-multi-test"><a class="header" href="#custom-error-and-multi-test">Custom error and multi-test</a></h2>
<p>Using proper custom error type has one nice upside - multi-test is maintaining error type using
the <a href="https://crates.io/crates/anyhow"><code>anyhow</code></a> crate. It is a sibling of <code>thiserror</code>, designed
to implement type-erased errors in a way that allows getting the original error back.</p>
<p>Let's write a test that verifies that a non-admin cannot add himself to a list:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{to_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn unauthorized() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg { admins: vec![] },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let err = app
            .execute_contract(
                Addr::unchecked(&quot;user&quot;),
                addr,
                &amp;ExecuteMsg::AddMembers {
                    admins: vec![&quot;user&quot;.to_owned()],
                },
                &amp;[],
            )
            .unwrap_err();

        assert_eq!(
            ContractError::Unauthorized {
                sender: Addr::unchecked(&quot;user&quot;)
            },
            err.downcast().unwrap()
        );
    }
}
</code></pre>
<p>Executing a contract is very similar to any other call - we use an
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/trait.Executor.html#method.execute_contract"><code>execute_contract</code></a>
function. As the execution may fail, we get an error type out of this call, but
instead of calling <code>unwrap</code> to extract a value out of it, we expect an error to
occur - this is the purpose of the
<a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err"><code>unwrap_err</code></a>
call. Now, as we have an error value, we can check if it matches what we
expected with an <code>assert_eq!</code>. There is a slight complication - the error
returned from <code>execute_contract</code> is an
<a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html"><code>anyhow::Error</code></a>
error, but we expect it to be a <code>ContractError</code>. Fortunately, as I said before,
<code>anyhow</code> errors can recover their original type using the
<a href="https://docs.rs/anyhow/1.0.57/anyhow/struct.Error.html#method.downcast"><code>downcast</code></a>
function. The <code>unwrap</code> right after it is needed because downcasting may fail.
The reason is that <code>downcast</code> doesn't magically know the type kept in the
underlying error. It deduces it by some context - here, it knows we expect it
to be a <code>ContractError</code>, because of being compared to it - type elision
miracles. But if the underlying error would not be a <code>ContractError</code>, then
<code>unwrap</code> would panic.</p>
<p>We just created a simple failure test for execution, but it is not enough to claim the contract is production-ready.
All reasonable ok-cases should be covered for that. I encourage you to create some tests and experiment with them as
an exercise after this chapter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events-attributes-and-data"><a class="header" href="#events-attributes-and-data">Events attributes and data</a></h1>
<p>The only way our contract can communicate to the world, for now, is by queries.
Smart contracts are passive - they cannot invoke any action by themselves. They
can do it only as a reaction to a call. But if you tried playing with <code>wasmd</code>,
you know that execution on the blockchain can return some metadata.</p>
<p>There are two things the contract can return to the caller: events and data.
Events are something produced by almost every real-life smart contract. In
contrast, data is rarely used, designed for contract-to-contract communication.</p>
<h2 id="returning-events"><a class="header" href="#returning-events">Returning events</a></h2>
<p>As an example, we would add an event <code>admin_added</code> emitted by our contract on the execution of
<code>AddMembers</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span>use cosmwasm_std::{
    to_binary, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
};
 
<span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>mod exec {
<span class="boring">    use super::*;
</span><span class="boring">
</span>    pub fn add_members(
        deps: DepsMut,
        info: MessageInfo,
        admins: Vec&lt;String&gt;,
    ) -&gt; Result&lt;Response, ContractError&gt; {
        let mut curr_admins = ADMINS.load(deps.storage)?;
        if !curr_admins.contains(&amp;info.sender) {
            return Err(ContractError::Unauthorized {
                sender: info.sender,
            });
        }

        let events = admins
            .iter()
            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
        let resp = Response::new()
            .add_events(events)
            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
            .add_attribute(&quot;added_count&quot;, admins.len().to_string());

        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
            .into_iter()
            .map(|addr| deps.api.addr_validate(&amp;addr))
            .collect();

        curr_admins.append(&amp;mut admins?);
        ADMINS.save(deps.storage, &amp;curr_admins)?;

        Ok(resp)
    }
<span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>An event is built from two things: an event type provided in the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Event.html#method.new"><code>new</code></a> function and attributes.
Attributes are added to an event with
the <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Event.html#method.add_attributes"><code>add_attributes</code></a>
or the  <a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Event.html#method.add_attribute"><code>add_attribute</code></a>
call. Attributes are key-value pairs. Because an event cannot contain any list, to achieve reporting
multiple similar actions taking place, we need to emit multiple small events instead of a collective one.</p>
<p>Events are emitted by adding them to the response with
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html#method.add_event"><code>add_event</code></a> or
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html#method.add_events"><code>add_events</code></a> call.
Additionally, there is a possibility to add attributes directly to the response. It is just sugar. By default,
every execution emits a standard &quot;wasm&quot; event. Adding attributes to the result adds them to the default event.</p>
<p>We can check if events are properly emitted by contract. It is not always done, as it is much of boilerplate in
test, but events are, generally, more like logs - not necessarily considered main contract logic. Let's now write
single test checking if execution emits events:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::ADMINS;
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn add_members() {
        let mut app = App::default();

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg {
                    admins: vec![&quot;owner&quot;.to_owned()],
                },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        let resp = app
            .execute_contract(
                Addr::unchecked(&quot;owner&quot;),
                addr,
                &amp;ExecuteMsg::AddMembers {
                    admins: vec![&quot;user&quot;.to_owned()],
                },
                &amp;[],
            )
            .unwrap();

        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
        assert_eq!(
            wasm.attributes
                .iter()
                .find(|attr| attr.key == &quot;action&quot;)
                .unwrap()
                .value,
            &quot;add_members&quot;
        );
        assert_eq!(
            wasm.attributes
                .iter()
                .find(|attr| attr.key == &quot;added_count&quot;)
                .unwrap()
                .value,
            &quot;1&quot;
        );

        let admin_added: Vec&lt;_&gt; = resp
            .events
            .iter()
            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
            .collect();
        assert_eq!(admin_added.len(), 1);

        assert_eq!(
            admin_added[0]
                .attributes
                .iter()
                .find(|attr| attr.key == &quot;addr&quot;)
                .unwrap()
                .value,
            &quot;user&quot;
        );
    }
}
</code></pre>
<p>As you can see, testing events on a simple test made it clunky. First of all,
every string is heavily string-based - a lack of type control makes writing
such tests difficult. Also, even types are prefixed with &quot;wasm-&quot; - it may not
be a huge problem, but it doesn't clarify verification. But the problem is, how
layered events structure are, which makes verifying them tricky. Also, the
&quot;wasm&quot; event is particularly tricky, as it contains an implied attribute -
<code>_contract_addr</code> containing an address called a contract. My general rule is -
do not test emitted events unless some logic depends on them.</p>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>Besides events, any smart contract execution may produce a <code>data</code> object. In contrast to events, <code>data</code>
can be structured. It makes it a way better choice to perform any communication logic relies on. On the
other hand, it turns out it is very rarely helpful outside of contract-to-contract communication. Data
is always only one single object on the response, which is set using the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Response.html#method.set_data"><code>set_data</code></a> function.
Because of its low usefulness in a single contract environment, we will not spend time on it right now - an
example of it will be covered later when contract-to-contract communication will be discussed. Until then,
it is just helpful to know such an entity exists.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dealing-with-funds"><a class="header" href="#dealing-with-funds">Dealing with funds</a></h1>
<p>When you hear smart contracts, you think blockchain. When you hear blockchain,
you often think of cryptocurrencies. It is not the same, but crypto assets, or
as we often call them: tokens, are very closely connected to the blockchain.
CosmWasm has a notion of a native token. Native tokens are assets managed by
the blockchain core instead of smart contracts. Often such assets have some
special meaning, like being used for paying <a href="https://docs.cosmos.network/master/basics/gas-fees.html">gas
fees</a> or
<a href="https://en.wikipedia.org/wiki/Proof_of_stake">staking</a> for consensus
algorithm, but can be just arbitrary assets.</p>
<p>Native tokens are assigned to their owners but can be transferred by their
nature. Everything had an address in the blockchain is eligible to have its
native tokens. As a consequence - tokens can be assigned to smart contracts!
Every message sent to the smart contract can have some funds sent with it. In
this chapter, we will take advantage of that and create a way to reward hard
work performed by admins. We will create a new message - <code>Donate</code>, which will be
used by anyone to donate some funds to admins, divided equally.</p>
<h2 id="preparing-messages"><a class="header" href="#preparing-messages">Preparing messages</a></h2>
<p>Traditionally we need to prepare our messages. We need to create a new
<code>ExecuteMsg</code> variant, but we will also modify the <code>Instantiate</code> message a bit -
we need to have some way of defining the name of a native token we would use
for donations. It would be possible to allow users to send any tokens they
want, but we want to simplify things for now.</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}
<span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
</span><span class="boring">pub enum QueryMsg {
</span><span class="boring">    Greet {},
</span><span class="boring">    AdminsList {},
</span><span class="boring">}
</span></code></pre>
<p>We also need to add a new state part, to keep the <code>donation_denom</code>:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use cw_storage_plus::Item;

pub const ADMINS: Item&lt;Vec&lt;Addr&gt;&gt; = Item::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
</code></pre>
<p>And instantiate it properly:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span>use crate::state::{ADMINS, DONATION_DENOM};
<span class="boring">use cosmwasm_std::{
</span><span class="boring">    to_binary, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span>
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
        .admins
        .into_iter()
        .map(|addr| deps.api.addr_validate(&amp;addr))
        .collect();
    ADMINS.save(deps.storage, &amp;admins?)?;
    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;

    Ok(Response::new())
}
<span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg { admins: vec![] },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn add_members() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;owner&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;action&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;add_members&quot;
</span><span class="boring">        );
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;added_count&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;1&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        let admin_added: Vec&lt;_&gt; = resp
</span><span class="boring">            .events
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
</span><span class="boring">            .collect();
</span><span class="boring">        assert_eq!(admin_added.len(), 1);
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            admin_added[0]
</span><span class="boring">                .attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;addr&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;user&quot;
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>What also needs some corrections are tests - instantiate messages have a new field. I leave it to you as an exercise.
Now we have everything we need to implement donating funds to admins. First, a minor update to the <code>Cargo.toml</code> - we
will use an additional utility crate:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[features]
library = []

[dependencies]
cosmwasm-std = { version = &quot;1.0.0-beta8&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.13.4&quot;
thiserror = &quot;1&quot;
schemars = &quot;0.8.1&quot;
cw-utils = &quot;0.13&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
cosmwasm-schema = { version = &quot;1.0.0&quot; }
</code></pre>
<p>Then we can implement the donate handler:</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::{ADMINS, DONATION_DENOM};
</span>use cosmwasm_std::{
    coins, to_binary, BankMsg, Binary, Deps, DepsMut, Env, Event, MessageInfo,
    Response, StdResult,
};
 
<span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    use ExecuteMsg::*;

    match msg {
        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
        Donate {} =&gt; exec::donate(deps, info),
    }
}

mod exec {
<span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn donate(deps: DepsMut, info: MessageInfo) -&gt; Result&lt;Response, ContractError&gt; {
        let denom = DONATION_DENOM.load(deps.storage)?;
        let admins = ADMINS.load(deps.storage)?;

        let donation = cw_utils::must_pay(&amp;info, &amp;denom)?.u128();

        let donation_per_admin = donation / (admins.len() as u128);

        let messages = admins.into_iter().map(|admin| BankMsg::Send {
            to_address: admin.to_string(),
            amount: coins(donation_per_admin, &amp;denom),
        });

        let resp = Response::new()
            .add_messages(messages)
            .add_attribute(&quot;action&quot;, &quot;donate&quot;)
            .add_attribute(&quot;amount&quot;, donation.to_string())
            .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());

        Ok(resp)
    }
}
<span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn add_members() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;owner&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;action&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;add_members&quot;
</span><span class="boring">        );
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;added_count&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;1&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        let admin_added: Vec&lt;_&gt; = resp
</span><span class="boring">            .events
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
</span><span class="boring">            .collect();
</span><span class="boring">        assert_eq!(admin_added.len(), 1);
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            admin_added[0]
</span><span class="boring">                .attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;addr&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;user&quot;
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>Sending the funds to another contract is performed by adding bank messages to
the response. The blockchain would expect any message which is returned in
contract response as a part of an execution. This design is related to an actor
model implemented by CosmWasm. The whole actor model will be described in
detail later. For now, you can assume this is a way to handle token transfers.
Before sending tokens to admins, we have to calculate the amount of donation
per admin. It is done by searching funds for an entry describing our donation
token and dividing the number of tokens sent by the number of admins. Note that
because the integral division is always rounding down.</p>
<p>As a consequence, it is possible that not all tokens sent as a donation would
end up with no admins accounts. Any leftover would be left on our contract
account forever. There are plenty of ways of dealing with this issue - figuring
out one of them would be a great exercise.</p>
<p>The last missing part is updating the <code>ContractError</code> - the <code>must_pay</code> call
returns a <code>cw_utils::PaymentError</code> which we can't convert to our error type
yet:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::{Addr, StdError};
use cw_utils::PaymentError;
use thiserror::Error;

#[derive(Error, Debug, PartialEq)]
pub enum ContractError {
    #[error(&quot;{0}&quot;)]
    StdError(#[from] StdError),
    #[error(&quot;{sender} is not contract admin&quot;)]
    Unauthorized { sender: Addr },
    #[error(&quot;Payment error: {0}&quot;)]
    Payment(#[from] PaymentError),
}
</code></pre>
<p>As you can see, to handle incoming funds, I used the utility function - I
encourage you to take a look at <a href="https://docs.rs/cw-utils/0.13.4/src/cw_utils/payment.rs.html#32-39">its
implementation</a> -
this would give you a good understanding of how incoming funds are structured
in <code>MessageInfo</code>.</p>
<p>Now it's time to check if the funds are distributed correctly. The way for that
is to write a test.</p>
<pre><code class="language-rust noplayground"><span class="boring">use crate::error::ContractError;
</span><span class="boring">use crate::msg::{AdminsListResp, ExecuteMsg, GreetResp, InstantiateMsg, QueryMsg};
</span><span class="boring">use crate::state::{ADMINS, DONATION_DENOM};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    coins, to_binary, BankMsg, Binary, Deps, DepsMut, Env, Event, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    _info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    let admins: StdResult&lt;Vec&lt;_&gt;&gt; = msg
</span><span class="boring">        .admins
</span><span class="boring">        .into_iter()
</span><span class="boring">        .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">        .collect();
</span><span class="boring">    ADMINS.save(deps.storage, &amp;admins?)?;
</span><span class="boring">    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;
</span><span class="boring">
</span><span class="boring">    Ok(Response::new())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    use QueryMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        Greet {} =&gt; to_binary(&amp;query::greet()?),
</span><span class="boring">        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    _env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    use ExecuteMsg::*;
</span><span class="boring">
</span><span class="boring">    match msg {
</span><span class="boring">        AddMembers { admins } =&gt; exec::add_members(deps, info, admins),
</span><span class="boring">        Leave {} =&gt; exec::leave(deps, info).map_err(Into::into),
</span><span class="boring">        Donate {} =&gt; exec::donate(deps, info),
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod exec {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn add_members(
</span><span class="boring">        deps: DepsMut,
</span><span class="boring">        info: MessageInfo,
</span><span class="boring">        admins: Vec&lt;String&gt;,
</span><span class="boring">    ) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let mut curr_admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        if !curr_admins.contains(&amp;info.sender) {
</span><span class="boring">            return Err(ContractError::Unauthorized {
</span><span class="boring">                sender: info.sender,
</span><span class="boring">            });
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        let events = admins
</span><span class="boring">            .iter()
</span><span class="boring">            .map(|admin| Event::new(&quot;admin_added&quot;).add_attribute(&quot;addr&quot;, admin));
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_events(events)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;add_members&quot;)
</span><span class="boring">            .add_attribute(&quot;added_count&quot;, admins.len().to_string());
</span><span class="boring">
</span><span class="boring">        let admins: StdResult&lt;Vec&lt;_&gt;&gt; = admins
</span><span class="boring">            .into_iter()
</span><span class="boring">            .map(|addr| deps.api.addr_validate(&amp;addr))
</span><span class="boring">            .collect();
</span><span class="boring">
</span><span class="boring">        curr_admins.append(&amp;mut admins?);
</span><span class="boring">        ADMINS.save(deps.storage, &amp;curr_admins)?;
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">        ADMINS.update(deps.storage, move |admins| -&gt; StdResult&lt;_&gt; {
</span><span class="boring">            let admins = admins
</span><span class="boring">                .into_iter()
</span><span class="boring">                .filter(|admin| *admin != info.sender)
</span><span class="boring">                .collect();
</span><span class="boring">            Ok(admins)
</span><span class="boring">        })?;
</span><span class="boring">
</span><span class="boring">        Ok(Response::new())
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn donate(deps: DepsMut, info: MessageInfo) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">        let denom = DONATION_DENOM.load(deps.storage)?;
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">
</span><span class="boring">        let donation = cw_utils::must_pay(&amp;info, &amp;denom)
</span><span class="boring">            .map_err(|err| StdError::generic_err(err.to_string()))?
</span><span class="boring">            .u128();
</span><span class="boring">
</span><span class="boring">        let donation_per_admin = donation / (admins.len() as u128);
</span><span class="boring">
</span><span class="boring">        let messages = admins.into_iter().map(|admin| BankMsg::Send {
</span><span class="boring">            to_address: admin.to_string(),
</span><span class="boring">            amount: coins(donation_per_admin, &amp;denom),
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        let resp = Response::new()
</span><span class="boring">            .add_messages(messages)
</span><span class="boring">            .add_attribute(&quot;action&quot;, &quot;donate&quot;)
</span><span class="boring">            .add_attribute(&quot;amount&quot;, donation.to_string())
</span><span class="boring">            .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod query {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    pub fn greet() -&gt; StdResult&lt;GreetResp&gt; {
</span><span class="boring">        let resp = GreetResp {
</span><span class="boring">            message: &quot;Hello World&quot;.to_owned(),
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
</span><span class="boring">        let admins = ADMINS.load(deps.storage)?;
</span><span class="boring">        let resp = AdminsListResp { admins };
</span><span class="boring">        Ok(resp)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
<span class="boring">    use cosmwasm_std::Addr;
</span><span class="boring">    use cw_multi_test::{App, ContractWrapper, Executor};
</span><span class="boring">
</span><span class="boring">    use crate::msg::AdminsListResp;
</span><span class="boring">
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn instantiation() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(resp, AdminsListResp { admins: vec![] });
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract 2&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: AdminsListResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::AdminsList {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            AdminsListResp {
</span><span class="boring">                admins: vec![Addr::unchecked(&quot;admin1&quot;), Addr::unchecked(&quot;admin2&quot;)],
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greet_query() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp: GreetResp = app
</span><span class="boring">            .wrap()
</span><span class="boring">            .query_wasm_smart(addr, &amp;QueryMsg::Greet {})
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            resp,
</span><span class="boring">            GreetResp {
</span><span class="boring">                message: &quot;Hello World&quot;.to_owned()
</span><span class="boring">            }
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn unauthorized() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let err = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;user&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap_err();
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            ContractError::Unauthorized {
</span><span class="boring">                sender: Addr::unchecked(&quot;user&quot;)
</span><span class="boring">            },
</span><span class="boring">            err.downcast().unwrap()
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn add_members() {
</span><span class="boring">        let mut app = App::default();
</span><span class="boring">
</span><span class="boring">        let code = ContractWrapper::new(execute, instantiate, query);
</span><span class="boring">        let code_id = app.store_code(Box::new(code));
</span><span class="boring">
</span><span class="boring">        let addr = app
</span><span class="boring">            .instantiate_contract(
</span><span class="boring">                code_id,
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                &amp;InstantiateMsg {
</span><span class="boring">                    admins: vec![&quot;owner&quot;.to_owned()],
</span><span class="boring">                    donation_denom: &quot;eth&quot;.to_owned(),
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">                &quot;Contract&quot;,
</span><span class="boring">                None,
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let resp = app
</span><span class="boring">            .execute_contract(
</span><span class="boring">                Addr::unchecked(&quot;owner&quot;),
</span><span class="boring">                addr,
</span><span class="boring">                &amp;ExecuteMsg::AddMembers {
</span><span class="boring">                    admins: vec![&quot;user&quot;.to_owned()],
</span><span class="boring">                },
</span><span class="boring">                &amp;[],
</span><span class="boring">            )
</span><span class="boring">            .unwrap();
</span><span class="boring">
</span><span class="boring">        let wasm = resp.events.iter().find(|ev| ev.ty == &quot;wasm&quot;).unwrap();
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;action&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;add_members&quot;
</span><span class="boring">        );
</span><span class="boring">        assert_eq!(
</span><span class="boring">            wasm.attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;added_count&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;1&quot;
</span><span class="boring">        );
</span><span class="boring">
</span><span class="boring">        let admin_added: Vec&lt;_&gt; = resp
</span><span class="boring">            .events
</span><span class="boring">            .iter()
</span><span class="boring">            .filter(|ev| ev.ty == &quot;wasm-admin_added&quot;)
</span><span class="boring">            .collect();
</span><span class="boring">        assert_eq!(admin_added.len(), 1);
</span><span class="boring">
</span><span class="boring">        assert_eq!(
</span><span class="boring">            admin_added[0]
</span><span class="boring">                .attributes
</span><span class="boring">                .iter()
</span><span class="boring">                .find(|attr| attr.key == &quot;addr&quot;)
</span><span class="boring">                .unwrap()
</span><span class="boring">                .value,
</span><span class="boring">            &quot;user&quot;
</span><span class="boring">        );
</span><span class="boring">    }
</span><span class="boring">
</span>    #[test]
    fn donations() {
        let mut app = App::new(|router, _, storage| {
            router
                .bank
                .init_balance(storage, &amp;Addr::unchecked(&quot;user&quot;), coins(5, &quot;eth&quot;))
                .unwrap()
        });

        let code = ContractWrapper::new(execute, instantiate, query);
        let code_id = app.store_code(Box::new(code));

        let addr = app
            .instantiate_contract(
                code_id,
                Addr::unchecked(&quot;owner&quot;),
                &amp;InstantiateMsg {
                    admins: vec![&quot;admin1&quot;.to_owned(), &quot;admin2&quot;.to_owned()],
                    donation_denom: &quot;eth&quot;.to_owned(),
                },
                &amp;[],
                &quot;Contract&quot;,
                None,
            )
            .unwrap();

        app.execute_contract(
            Addr::unchecked(&quot;user&quot;),
            addr.clone(),
            &amp;ExecuteMsg::Donate {},
            &amp;coins(5, &quot;eth&quot;),
        )
        .unwrap();

        assert_eq!(
            app.wrap()
                .query_balance(&quot;user&quot;, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            0
        );

        assert_eq!(
            app.wrap()
                .query_balance(&amp;addr, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            1
        );

        assert_eq!(
            app.wrap()
                .query_balance(&quot;admin1&quot;, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            2
        );

        assert_eq!(
            app.wrap()
                .query_balance(&quot;admin2&quot;, &quot;eth&quot;)
                .unwrap()
                .amount
                .u128(),
            2
        );
    }
}
</code></pre>
<p>Fairly simple. I don't particularly appreciate that every balance check is
eight lines of code, but it can be improved by enclosing this assertion into a
separate function, probably with the
<a href="https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-track_caller-attribute"><code>#[track_caller]</code></a>
attribute.</p>
<p>The critical thing to talk about is how <code>app</code> creation changed. Because we need
some initial tokens on a <code>user</code> account, instead of using the default
constructor, we have to provide it with an initializer function. Unfortunately,
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.App.html#method.new"><code>new</code></a>
documentation is not easy to follow - even if a function is not very
complicated. What it takes as an argument is a closure with three arguments -
the
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.Router.html"><code>Router</code></a>
with all modules supported by multi-test, the API object, and the state. This
function is called once during contract instantiation. The <code>router</code> object
contains some generic fields - we are interested in <code>bank</code> in particular. It
has a type of
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.BankKeeper.html"><code>BankKeeper</code></a>,
where the
<a href="https://docs.rs/cw-multi-test/0.13.4/cw_multi_test/struct.BankKeeper.html#method.init_balance"><code>init_balance</code></a>
function sits.</p>
<h2 id="plot-twist"><a class="header" href="#plot-twist">Plot Twist!</a></h2>
<p>As we covered most of the important basics about building Rust smart contracts, I have a serious exercise for you.</p>
<p>The contract we built has an exploitable bug. All donations are distributed equally across admins. However, every
admin is eligible to add another admin. And nothing is preventing the admin from adding himself to the list and
receiving twice as many rewards as others!</p>
<p>Try to write a test that detects such a bug, then fix it and ensure the bug nevermore occurs.</p>
<p>Even if the admin cannot add the same address to the list, he can always create new accounts and add them, but this
is something unpreventable on the contract level, so do not prevent that. Handling this kind of case is done by
properly designing whole applications, which is out of this chapter's scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="good-practices"><a class="header" href="#good-practices">Good practices</a></h1>
<p>All the relevant basics are covered. Now let's talk about some good practices.</p>
<h2 id="json-renaming"><a class="header" href="#json-renaming">JSON renaming</a></h2>
<p>Due to Rust style, all our message variants are spelled in a
<a href="https://en.wikipedia.org/wiki/CamelCase">camel-case</a>. It is standard practice,
but it has a drawback - all messages are serialized and deserialized by serde
using those variant names. The problem is that it is more common to use <a href="https://en.wikipedia.org/wiki/Snake_case">snake
cases</a> for field names in the JSON
world. Fortunately, there is an effortless way to tell serde, to change the names
casing for serialization purposes. Let's update our messages with a <code>#[serde]</code>
attribute:</p>
<pre><code class="language-rust noplayground">use cosmwasm_std::Addr;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct AdminsListResp {
    pub admins: Vec&lt;Addr&gt;,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}
</code></pre>
<h2 id="json-schema"><a class="header" href="#json-schema">JSON schema</a></h2>
<p>Talking about JSON API, it is worth mentioning JSON Schema. It is a way of defining a shape for JSON messages.
It is good practice to provide a way to generate schemas for contract API. The problem is that writing JSON
schemas by hand is a pain. The good news is that there is a crate that would help us with that. Go to the <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;contract&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies]
cosmwasm-std = { version = &quot;1.1.4&quot;, features = [&quot;staking&quot;] }
serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
cw-storage-plus = &quot;0.15.1&quot;
thiserror = &quot;1&quot;
schemars = &quot;0.8.1&quot;
cosmwasm-schema = &quot;1.1.4&quot;

[dev-dependencies]
cw-multi-test = &quot;0.13.4&quot;
</code></pre>
<p>There is one additional change in this file - in <code>crate-type</code> I added &quot;rlib&quot;. &quot;cdylib&quot; crates cannot be used as typical
Rust dependencies. As a consequence, it is impossible to create examples for such crates.</p>
<p>Now go back to <code>src/msg.rs</code> and add a new derive for all messages:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span>use schemars::JsonSchema;
<span class="boring">use serde::{Deserialize, Serialize};
</span>
#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct GreetResp {
    pub message: String,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub struct AdminsListResp {
    pub admins: Vec&lt;Addr&gt;,
}

#[derive(Serialize, Deserialize, PartialEq, Debug, Clone, JsonSchema)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}
</code></pre>
<p>You may argue that all those derives look slightly clunky, and I agree.
Fortunately, the
<a href="https://docs.rs/cosmwasm-schema/1.1.4/cosmwasm_schema/#"><code>cosmwasm-schema</code></a>
crate delivers a utility <code>cw_serde</code> macro, which we can use to reduce a
boilerplate:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span>use cosmwasm_schema::cw_serde

#[cw_serde]
pub struct InstantiateMsg {
    pub admins: Vec&lt;String&gt;,
    pub donation_denom: String,
}

#[cw_serde]
pub enum ExecuteMsg {
    AddMembers { admins: Vec&lt;String&gt; },
    Leave {},
    Donate {},
}

#[cw_serde]
pub struct GreetResp {
    pub message: String,
}

#[cw_serde]
pub struct AdminsListResp {
    pub admins: Vec&lt;Addr&gt;,
}

#[cw_serde]
pub enum QueryMsg {
    Greet {},
    AdminsList {},
}
</code></pre>
<p>Additionally, we have to derive the additional <code>QueryResponses</code> trait for our
query message to correlate the message variants with responses we would
generate for them:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::Addr;
</span>use cosmwasm_schema::{cw_serde, QueryResponses}

<span class="boring">#[cw_serde]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;String&gt;,
</span><span class="boring">    pub donation_denom: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub enum ExecuteMsg {
</span><span class="boring">    AddMembers { admins: Vec&lt;String&gt; },
</span><span class="boring">    Leave {},
</span><span class="boring">    Donate {},
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct GreetResp {
</span><span class="boring">    pub message: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(GreetResp)]
    Greet {},
    #[returns(AdminsListResp)]
    AdminsList {},
}
</code></pre>
<p>The <code>QueryResponses</code> is a trait that requires the <code>#[returns(...)]</code> attribute
to all your query variants to generate additional information about the
query-response relationship.</p>
<p>Now, we want to make the <code>msg</code> module public and accessible by crates depending
on our contract (in this case - for schema example). Update a <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">use error::ContractError;
</span><span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span><span class="boring">
</span>pub mod contract;
pub mod error;
pub mod msg;
pub mod state;
<span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn instantiate(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: InstantiateMsg,
</span><span class="boring">) -&gt; StdResult&lt;Response&gt; {
</span><span class="boring">    contract::instantiate(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn execute(
</span><span class="boring">    deps: DepsMut,
</span><span class="boring">    env: Env,
</span><span class="boring">    info: MessageInfo,
</span><span class="boring">    msg: ExecuteMsg,
</span><span class="boring">) -&gt; Result&lt;Response, ContractError&gt; {
</span><span class="boring">    contract::execute(deps, env, info, msg)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[entry_point]
</span><span class="boring">pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
</span><span class="boring">    contract::query(deps, env, msg)
</span><span class="boring">}
</span></code></pre>
<p>I changed the visibility of all modules - as our crate can now be used as a dependency.
If someone would like to do so, he may need access to handlers or state. </p>
<p>The next step is to create a tool generating actual schemas. We will do it by creating
an binary in our crate. Create a new <code>bin/schema.rs</code> file:</p>
<pre><code class="language-rust noplayground">use contract::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
use cosmwasm_schema::write_api;

fn main() {
    write_api! {
        instantiate: InstantiateMsg,
        execute: ExecuteMsg,
        query: QueryMsg
    }
}
</code></pre>
<p>Cargo is smart enough to recognize files in <code>src/bin</code> directory as utility
binaries for the crate. Now we can generate our schemas:</p>
<pre><code>$ cargo run schema
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/schema schema`
Removing &quot;/home/hashed/confio/git/book/examples/03-basics/schema/contract.json&quot; …
Exported the full API as /home/hashed/confio/git/book/examples/03-basics/schema/contract.json
</code></pre>
<p>I encourage you to go to generated file to see what the schema looks like.</p>
<p>The problem is that, unfortunately, creating this binary makes our project fail
to compile on the Wasm target - which is, in the end, the most important one.
Fortunately, we don't need to build the schema binary for the Wasm target - let's
align the <code>.cargo/config</code> file:</p>
<pre><code class="language-toml">[alias]
wasm = &quot;build --target wasm32-unknown-unknown --release --lib&quot;
wasm-debug = &quot;build --target wasm32-unknown-unknown --lib&quot;
schema = &quot;run schema&quot;
</code></pre>
<p>The <code>--lib</code> flag added to <code>wasm</code> cargo aliases tells the toolchain to build
only the library target - it would skip building any binaries. Additionally, I
added the convenience <code>schema</code> alias so that one can generate schema calling
simply <code>cargo schema</code>.</p>
<h2 id="disabling-entry-points-for-libraries"><a class="header" href="#disabling-entry-points-for-libraries">Disabling entry points for libraries</a></h2>
<p>Since we added the &quot;rlib&quot; target for the contract, it is, as mentioned before, useable as a dependency.
The problem is that the contract depended on ours would have Wasm entry points generated twice - once
in the dependency and once in the final contract. We can work this around by disabling generating Wasm
entry points for the contract if the crate is used as a dependency. We would use
<a href="https://doc.rust-lang.org/cargo/reference/features.html">feature flags</a> for that.</p>
<p>Start with updating <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
library = []
</code></pre>
<p>This way, we created a new feature for our crate. Now we want to disable the <code>entry_point</code> attribute on
entry points - we will do it by a slight update of <code>src/lib.rs</code>:</p>
<pre><code class="language-rust noplayground"><span class="boring">use cosmwasm_std::{entry_point, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
</span><span class="boring">use error::ContractError;
</span><span class="boring">use msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
</span><span class="boring">
</span><span class="boring">pub mod contract;
</span><span class="boring">pub mod error;
</span><span class="boring">pub mod msg;
</span><span class="boring">pub mod state;
</span><span class="boring">
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    contract::instantiate(deps, env, info, msg)
}

#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    contract::execute(deps, env, info, msg)
}

#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    contract::query(deps, env, msg)
}
</code></pre>
<p>The <a href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute"><code>cfg_attr</code></a> attribute is
a conditional compilation attribute, similar to the <code>cfg</code> we used before for the test. It expands to the given attribute if
the condition expands to true. In our case - it would expand to nothing if the feature &quot;library&quot; is enabled, or it
would expand just to <code>#[entry_point]</code> in another case.</p>
<p>Since now to add this contract as a dependency, don't forget to enable the feature like this:</p>
<pre><code class="language-toml">[dependencies]
my_contract = { version = &quot;0.1&quot;, features = [&quot;library&quot;] }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floating-point-types"><a class="header" href="#floating-point-types">Floating point types</a></h1>
<p>Now you are ready to create smart contracts on your own. It is time to discuss an important limitation of CosmWasm
smart contracts - floating-point numbers.</p>
<p>The story is short: you cannot use floating-point types in smart contracts. Never. CosmWasm virtual machine on purpose
does not implement floating-point Wasm instructions, even such basics as <code>F32Load</code>. The reasoning is simple: they are
not safe to work with in the blockchain world.</p>
<p>The biggest problem is that contract will compile, but uploading it to the blockchain would fail with an error message claiming there is a floating-point operation in the contract. A tool that verifies if the contract is valid (it does not contain any fp operations but also has all needed entry points and so on) is called <code>cosmwasm-check</code> <a href="https://github.com/CosmWasm/cosmwasm/tree/main/packages/check">utility</a>.</p>
<p>This limitation has two implications. First, you always have to use decimal of fixed-point arithmetic in your contracts.
It is not a problem, considering that <code>cosmwasm-std</code> provides you with the
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Decimal.html"><code>Decimal</code></a> and
<a href="https://docs.rs/cosmwasm-std/1.0.0/cosmwasm_std/struct.Decimal256.html">Decimal256</a> types.</p>
<p>The other implication is tricky - you must be careful with the crates you use. In particular, one gotcha in the <code>serde</code>
crate - deserialization of <code>usize</code> type is using floating-point operations. That means you can never use <code>usize</code> (or <code>isize</code>)
types in your deserialized messages in the contract.</p>
<p>Another thing that will not work with serde is untagged enums deserialization. The workaround is to create custom
deserialization of such enums using <a href="https://crates.io/crates/serde-cw-value"><code>serde-cw-value</code></a> crate. It is a fork of
<a href="https://crates.io/crates/serde-value"><code>serde-value</code></a> crate which avoids generating floating-point instructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor-model"><a class="header" href="#actor-model">Actor model</a></h1>
<p>This section describes the fundaments of CosmWasm smart contracts architecture, which determines how do they communicate
with each other. I want to go through this before teaching step by step how to create multiple contracts relating to each
other, to give you a grasp of what to expect. Don't worry if it will not be clear after the first read - I suggest going
through this chapter once now and maybe giving it another take in the future when you know the practical part of this.</p>
<p>The whole thing described here is officially documented in the
<a href="https://github.com/CosmWasm/cosmwasm/blob/main/SEMANTICS.md">SEMANTICS.md</a>, of the <code>cosmwasm</code> repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea-behind-an-actor-model"><a class="header" href="#idea-behind-an-actor-model">Idea behind an Actor Model</a></h1>
<p>The actor model is the solution to the problem of communication between smart
contracts. Let's take a look at the reasons why this particular solution is
chosen in CosmWasm, and what are the consequences of that.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>Smart contracts can be imagined as sandboxed microservices. Due to
<a href="https://en.wikipedia.org/wiki/SOLID">SOLID</a> principles, it is valuable to
split responsibilities between entities. However, to split the work between
contracts themselves, there is a need to communicate between them, so if one
contract is responsible for managing group membership, it is possible to call
its functionality from another contract.</p>
<p>The traditional way to solve this problem in SW engineering is to model
services as functions that would be called with some RPC mechanism, and return
its result as a response. Even though this approach looks nice, it creates sort
of problems, in particular with shared state consistency.</p>
<p>The other approach which is far more popular in business-level modeling is to
treat entities as actors, which can perform some tasks, but without
interrupting it with calls to other contracts. Any calls to other contracts can
only be called after the whole execution is performed. When &quot;subcall&quot; is
finished, it will call the original contract back.</p>
<p>This solution may feel unnatural, and it requires different kinds of design
solutions, but it turns out to work pretty well for smart contract execution.
I will try to explain how to reason about it, and how it maps to contract
structure step by step.</p>
<h2 id="the-actor"><a class="header" href="#the-actor">The Actor</a></h2>
<p>The most important thing in the whole model is an Actor itself. So, what is
this? The Actor is a single instantiation of a contract, which can perform
several actions. When the actor finishes his job, he prepares a summary of it,
which includes the list of things that have to be done, to complete the whole
scheduled task.</p>
<p>An example of an actor is the Seller in the KFC restaurant. The first thing you
do is order your BSmart, so you are requesting action from him. So, from the
system user, you can think about this task as &quot;sell and prepare my meal&quot;, but
the action performed by the seller is just &quot;Charge payment and create order&quot;.
The first part of this operation is to create a bill and charge you for it, and
then it requests the Sandwich and Fries to be prepared by other actors,
probably chefs. Then when the chef is done with his part of the meal, he checks
if all meals are ready. If so, it calls the last actor, the waiter, to deliver
the food to you. At this point, you can receive your delivery, and the task is
considered complete.</p>
<p>The above-described workflow is kind of simplified. In particular - in a
typical restaurant, a waiter would observe the kitchen instead of being
triggered by a chef, but in the Actor model, it is not possible. Here, entities
of the system are passive and cannot observe the environment actively - they
only react to messages from other system participants. Also in KFC, the seller
would not schedule subtasks for particular chefs; instead, he would leave tasks
to be taken by them, when they are free. It is not the case, because as before -
chefs cannot actively listen to the environment. However, it would be possible
to create a contract for being a chef's dispatcher which would collect all
orders from sellers, and balance them across chefs for some reason.</p>
<h2 id="the-action"><a class="header" href="#the-action">The Action</a></h2>
<p>Actors are the model entities, but to properly communicate with them, we need
some kind of protocol. Every actor is capable of performing several actions. In
my previous KFC example, the only action seller can do is &quot;Charge payment and
create order&quot;. However, it is not always the case - our chefs were proficient
at performing both &quot;Prepare fries&quot; and &quot;Prepare Sandwich&quot; actions - and also
many more.</p>
<p>So, when we want to do something in an actor system, we schedule some action to
the actor being the closest to us, very often with some additional parameters
(as we can pick if we want to exchange fries with salad).</p>
<p>However, naming the action after the exact thing which happened in the very
contract would be misleading. Take a look at the KFC example once again. As I
mentioned, the action performed by a seller is &quot;Charge payment and create
order&quot;. The problem is, that for the client who schedules this action, it
doesn't matter what exactly is the responsibility of the actor himself - what
the client is scheduling is &quot;Prepare Meal&quot; with some description of what
exactly to prepare. So, we can say, that the action is the thing performed by
the contract itself, plus all the sub-actions it schedules.</p>
<h2 id="multi-stage-actions"><a class="header" href="#multi-stage-actions">Multi-stage Actions</a></h2>
<p>So as the whole idea makes some sense, there is the problem created by the
actor model: what if I want to perform some action in my contract, but to
completely finalize some steps, the contract has to make sure that some
sub-action he scheduled are finished?</p>
<p>Imagine that in the previous KFC situation, there is no dedicated Waiter.
Instead the Seller was serving you a meal when the Chefs finished their job.</p>
<p>This kind of pattern is so important and common that in CosmWasm, we developed
a special way to handle it, which is dedicated <code>Reply</code> action.</p>
<p>So when Seller is scheduling actions for chefs, he assigns some number to this
action (like order id) and passes it to chefs. He also remembers how many
actions he scheduled for every order id. Now every time chef is finished with
his action; he would call the special <code>Reply</code> action on Seller, in which he
would pass back the order id. Then, Seller would decrease the number of actions
left for this order, and if it reached zero, he would serve a meal.</p>
<p>Now you can say, that the <code>Reply</code> action is completely not needed, as Chefs
could just schedule any arbitrary action on Seller, like <code>Serve</code>, why is there
the special <code>Reply</code> for? The reason is abstraction and reusability. The Chefs
task is to prepare a meal, and that is all. There is no reason for him to know
why he is even preparing Fries - if it is part of the bigger task (like order
for a client), or the seller is just hungry. It is possible that not only the
seller is eligible to call the chef for food - possibly any restaurant employee
can do that just for themselves. Therefore, we need a way to be able to react
to an actor finishing his job in some universal way, to handle this situation
properly in any context.</p>
<p>It is worth noting that the <code>Reply</code> can contain some additional data. The id
assigned previously is the only required information in the <code>Reply</code> call, but
the actor can pass some additional data - <code>events</code> emitted, which are mostly
metadata (to be observed by non-blockchain applications mostly), and any
arbitrary data it wants to pass.</p>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>Up until this point, we were considering actors as entities performing some
job, like preparing the meal. If we are considering computer programs, such a
job would be to show something on the screen, maybe print something. This is
not the case with Smart Contracts. The only thing which can be affected by the
Smart Contract is their internal state. So, the state is arbitrary data that is
kept by the contract. Previously in the KFC example I mentioned, the Seller is
keeping in mind how many actions he scheduled for chefs are not yet finished -
this number is part of the Seller's state.</p>
<p>To give a more realistic example of a contract state, let's think about a more
real-life Smart Contract than the restaurant. Let's imagine we want to create
our currency - maybe we want to create some smart contracts-based market for
some MMORPG game. So, we need some way to be able to at least transfer currency
between players. We can do that, by creating the contract we would call
<code>MmoCurrency</code>, which would support the <code>Transfer</code> action to transfer money to
another player. Then what would be the state of such a contract? It would be
just a table mapping player names to the amount of currency they own. The
contract we just invited exists in CosmWasm examples, and it is called the
<a href="https://github.com/CosmWasm/cw-plus/tree/main/contracts/cw20-base"><code>cw20-base</code>
contract</a>
(it is a bit more complicated, but it is its core idea).</p>
<p>And now there is a question - how is this helpful to transfer currency if I
cannot check how much of it do I own? It is a very good question, and the
answer to that is simple - the whole state of every contract in our system is
public. It is not universal for every Actor model, but it is how it works in
CosmWasm, and it is kind of forced by the nature of blockchain. Everything
happening in blockchain has to be public, and if some information should be
hidden, it has to be stored indirectly.</p>
<p>There is one very important thing about the state in CosmWasm, and it is the
state being transactional. Any updates to the state are not applied
immediately, but only when the whole action succeeds. It is very important, as
it guarantees that if something goes wrong in the contract, it is always left
in some proper state. Let's consider our <code>MmoCurrency</code> case. Imagine, that in
the <code>Transfer</code> action we first increase the receiver currency amount (by
updating the state), and only then do we decrease the sender amount. However,
before decreasing it, we need to check if a sender possesses enough funds to
perform the transaction. In case we realize that we cannot do it, we don't need
to do any rolling back by hand - we would just return a failure from the action
execution, and the state would not be updated. So, when in the contract state
is updated, it is just a local copy of this state being altered, but the
partial changes would never be visible by other contracts.</p>
<h2 id="queries"><a class="header" href="#queries">Queries</a></h2>
<p>There is one building block in the CosmWasm approach to the Actor model, which
I haven't yet cover. As I said, the whole state of every contract is public and
available for everyone to look at. The problem is that this way of looking at
state is not very convenient - it requires users of contracts to know its
internal structure, which kind of violates the SOLID rules (Liskov substitution
principle in particular). If, for example a contract is updated and its state
structure changes a bit, another contract looking at its state would just
nevermore work. Also, it is often the case, that the contract state is kind of
simplified, and information that is relevant to the observer would be
calculated from the state.</p>
<p>This is where queries come into play. Queries are the type of messages to
contract, which does not perform any actions, so do not update any state, but
can return an answer immediately.</p>
<p>In our KFC comparison, the query would be if Seller goes to Chef to ask &quot;Do we
still have pickles available for our cheeseburgers&quot;? It can be done while
operating, and response can be used in it. It is possible because queries can
never update their state, so they do not need to be handled in a transactional
manner.</p>
<p>However, the existence of queries doesn't mean that we cannot look at the
contract's state directly - the state is still public, and the technique of
looking at them directly is called <code>Raw Queries</code>. For clarity, non-raw queries
are sometimes denoted as <code>Smart Queries</code>.</p>
<h2 id="wrapping-everything-together---transactional-call-flow"><a class="header" href="#wrapping-everything-together---transactional-call-flow">Wrapping everything together - transactional call flow</a></h2>
<p>So, we touched on many things here, and I know it may be kind of confusing.
Because of that, I would like to go through some more complicated calls to the
CosmWasm contract to visualize what the &quot;transactional state&quot; means.</p>
<p>Let's imagine two contracts:</p>
<ol>
<li>The <code>MmoCurrency</code> contract mentioned before, which can perform the
<code>Transfer</code> action, allows transferring some <code>amount</code> of currency to some
<code>receiver</code>.</li>
<li>The <code>WarriorNpc</code> contract, which would have some amount of our currency, and
he would be used by our MMO engine to pay the reward out for some quest
player could perform. It would be triggered by <code>Payout</code> action, which can be
called only by a specific client (which would be our game engine).</li>
</ol>
<p>Now here is an interesting thing - this model forces us to make our MMO more
realistic in terms of the economy that we traditionally see - it is because
<code>WarriorNpc</code> has some amount of currency, and cannot create more out of
anything. It is not always the case (the previously mentioned <code>cw20</code> has a
notion of Minting for this case), but for the sake of simplicity let's assume this
is what we want.</p>
<p>To make the quest reasonable for longer, we would make a reward for it to be
always between <code>1 mmo</code> and <code>100 mmo</code>, but it would be ideally <code>15%</code> of what
Warrior owns. This means that the quest reward decreases for every subsequent
player, until Warrior would be broke, left with nothing, and will no longer be
able to payout players.</p>
<p>So, what would the flow look like? The first game would send a <code>Payout</code> message
to the <code>WarriorNpc</code> contract, with info on who should get the reward. Warrior
would keep track of players who fulfilled the quest, to not pay out the same
person twice - there would be a list of players in his state. First, he would
check the list looking for players to pay out - if he is there, he will finish
the transaction with an error.</p>
<p>However, in most cases the player would not be on the list - so then
<code>WarriorNpc</code> would add him to the list. Now the Warrior would finish his part
of the task, and schedule the <code>Transfer</code> action to be performed by
<code>MmoCurrency</code>.</p>
<p>But there is the important thing - because <code>Transfer</code> action is actually part
of the bigger <code>Payout</code> flow, it would not be executed on the original
blockchain state, but on the local copy of it, to which the player's list is
already applied to. So if the <code>MmoCurrency</code> would for any reason takes a look
at <code>WarriorNpc</code> internal list, it would be already updated.</p>
<p>Now <code>MmoCurrency</code> is doing its job, updating the state of Warrior and player
balance (note, that our Warrior is here just treated as another player!). When
it finishes, two things may happen:</p>
<ol>
<li>There was an error - possibly Warrior is out of cash, and it can nevermore
pay for the task. In such case, none of the changes - neither updating the
list of players succeeding, nor balance changes are not applied to the
original blockchain storage, so they are like they never happened. In the
database world, it is denoted as rolling back the transaction.</li>
<li>Operation succeed - all changes on the state are now applied to the
blockchain, and any further observation of <code>MmoCurrency</code> or <code>WarriorNpc</code> by
the external world would see updated data.</li>
</ol>
<p>There is one problem - in this model, our list is not a list of players who
fulfilled the quest (as we wanted it to be), but the list of players who paid
out (as in transfer failure, the list is not updated). We can do better.</p>
<h2 id="different-ways-of-handling-responses"><a class="header" href="#different-ways-of-handling-responses">Different ways of handling responses</a></h2>
<p>Note that we didn't mention a <code>Reply</code> operation at all. So why was it not
called by <code>MmoCurrency</code> on <code>WarriorNpc</code>? The reason is that this operation is
optional. When scheduling sub-actions on another contract we may choose when
<code>Reply</code> how the result should be handled:</p>
<ol>
<li>Never call <code>Reply</code>, action fails if sub-message fails</li>
<li>Call <code>Reply</code> on success</li>
<li>Call <code>Reply</code> on failure</li>
<li>Always call <code>Reply</code></li>
</ol>
<p>So, if we do not request <code>Reply</code> to be called by subsequent contract, it will
not happen. In such a case if a sub-call fails, the whole transaction is rolled
back - sub-message failure transitively causes the original message failure. It
is probably a bit complicated for now, but I promise it would be simple if you
would did some practice with that.</p>
<p>When handling the reply, it is important to remember, that although changes are
not yet applied to the blockchain (the transaction still can be failed), the
reply handler is already working on the copy of the state with all changes made
by sub-message so far applied. In most cases, it would be a good thing, but it
has a tricky consequence - if the contract is calling itself recursively, it is
possible that subsequent call overwrote things set up in the original message.
It rarely happens, but may need special treatment in some cases - for now I
don't want to go deeply into details, but I want you to remember about what to
expect after state in the actor's flow.</p>
<p>Now let's take a look at handling results with <code>2</code>-<code>4</code> options. It is actually
interesting, that using <code>2</code>, even if the transaction is performed by sub-call
succeed, we may now take a look at the data it returned with <code>Reply</code>, and on
its final state after it finished, and we can still decide, that act as a
whole is a failure, in which case everything would be rolled back - even
currency transfer performed by external contract.</p>
<p>In our case, an interesting option is <code>3</code>. So, if the contract would call
<code>Reply</code> on failure, we can decide to claim success, and commit a transaction on
the state if the sub call failed. Why may it be relevant for us? Possibly
because our internal list was supposed to keep the list of players succeeding
with the quest, not paid out! So, if we have no more currency, we still want to
update the list!</p>
<p>The most common way to use the replies (option <code>2</code> in particular)  is to
instantiate another contract, managed by the one called. The idea is that in
those use cases, the creator contract wants to keep the address of the created
contract in its state. To do so it has to create an <code>Instantiate</code> sub-message,
and subscribe for its success response, which contains the address of the freshly
created contract.</p>
<p>In the end, you can see that performing actions in CosmWasm is built with
hierarchical state change transactions. The sub-transaction can be applied to
the blockchain only if everything succeeds, but in case that sub-transaction
failed, only its part may be rolled back, end other changes may be applied. It
is very similar to how most database systems work.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Now you have seen the power of the actor model to avoid reentrancy, properly
handle errors, and safely sandbox contracts. This helps us provide the solid
security guarantees of the CosmWasm platform. Let’s get started playing around
with real contracts in the <code>wasmd</code> blockchain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actors-in-blockchain"><a class="header" href="#actors-in-blockchain">Actors in blockchain</a></h1>
<p>Previously we were talking about actors mostly in the abstraction of any
blockchain-specific terms. However, before we would dive into the code, we need
to establish some common language, and to do so we would look at contracts from
the perspective of external users, instead of their implementation.</p>
<p>In this part, I would use the <code>wasmd</code> binary to communicate with the malaga
testnet. To properly set it up, check the <a href="actor-model/../wasmd-quick-start.html">Quick start with
<code>wasmd</code></a>.</p>
<h2 id="blockchain-as-a-database"><a class="header" href="#blockchain-as-a-database">Blockchain as a database</a></h2>
<p>It is kind of starting from the end, but I would start with the state part of
the actor model. Relating to traditional systems, there is one particular thing
I like to compare blockchain with - it is a database.</p>
<p>Going back to the previous section we learned that the most important part of
a contract is its state. Manipulating the state is the only way to persistently
manifest work performed to the world. But What is the thing which purpose is to
keep the state? It is a database!</p>
<p>So here is my (as a contract developer) point of view on contracts: it is a distributed
database, with some magical mechanisms to make it democratic. Those &quot;magical
mechanisms&quot; are crucial for BC's existence and they make they are reasons why even
use blockchain, but they are not relevant from the contract creator's point of
view - for us, everything that matters is the state.</p>
<p>But you can say: what about the financial part?! Isn't blockchain (<code>wasmd</code> in particular)
the currency implementation? With all of those gas costs, sending funds seems
very much like a money transfer, not database updates. And yes, you are kind of right,
but I have a solution for that too. Just imagine, that for every native token (by
&quot;native tokens&quot; we meant tokens handled directly by blockchain, in contradiction
to for example cw20 tokens) there is a special database bucket (or table if you prefer)
with mapping of address to how much of a token the address possesses. You can query
this table (querying for token balance), but you cannot modify it directly. To modify
it you just send a message to a special build-in bank contract. And everything
is still a database.</p>
<p>But if blockchain is a database, then where are smart contracts stored?
Obviously - in the database itself! So now imagine another special table - this
one would contain a single table of code-ids mapped to blobs of wasm binaries. And
again - to operate on this table, you use &quot;special contract&quot; which is not accessible
from another contract, but you can use it via <code>wasmd</code> binary.</p>
<p>Now there is a question - why do I even care about BC being a DB? So the reason
is that it makes reasoning about everything in blockchain very natural. Do you
remember that every message in the actor model is transactional? It perfectly
matches traditional database transactions (meaning: every message starts a new
transaction)! Also, when we later talk about migrations, it would turn out, that
migrations in CosmWasm are very much equivalents of schema migrations in
traditional databases.</p>
<p>So, the thing to remember - blockchain is very similar to a database, having some
specially reserved tables (like native tokens, code repository), with a special
bucket created for every contract. A contract can look at every table in every
bucket in the whole blockchain, but it can modify the only one he created.</p>
<h2 id="compile-the-contract"><a class="header" href="#compile-the-contract">Compile the contract</a></h2>
<p>I will not go into the code for now, but to start with something we need compiled
contract binary. The <code>cw4-group</code> contract from
<a href="https://github.com/CosmWasm/cw-plus">cw-plus</a> is simple enough to work with, for
now, so we will start with compiling it. Start with cloning the repository:</p>
<pre><code class="language-bash">$ git clone git@github.com:CosmWasm/cw-plus.git
</code></pre>
<p>Then go to <code>cw4-group</code> contract and build it:</p>
<pre><code class="language-bash">$ cd cw-plus/contracts/cw4-group
$ docker run --rm -v &quot;$(pwd)&quot;:/code \
  --mount type=volume,source=&quot;$(basename &quot;$(pwd)&quot;)_cache&quot;,target=/code/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/workspace-optimizer:0.12.6
</code></pre>
<p>Your final binary should be located in the
<code>cw-plus/artifacts</code> folder (<code>cw-plus</code> being where you cloned your repository).</p>
<h2 id="contract-code"><a class="header" href="#contract-code">Contract code</a></h2>
<p>When the contract binary is built, the first interaction with CosmWasm is uploading
it to the blockchain (assuming you have your wasm binary in the working directory):</p>
<pre><code class="language-bash">$ wasmd tx wasm store ./cw4-group.wasm --from wallet $TXFLAG -y -b block
</code></pre>
<p>As a result of such an operation you would get json output like this:</p>
<pre><code>..
logs:
..
- events:
  ..
  - attributes:
    - key: code_id
      value: &quot;1069&quot;
    type: store_code
</code></pre>
<p>I ignored most of not fields as they are not relevant for now - what we care
about is the event emitted by blockchain with information about <code>code_id</code> of
stored contract - in my case the contract code was stored in blockchain under
the id of <code>1069</code>. I can now look at the code by querying for it:</p>
<pre><code class="language-bash">$ wasmd query wasm code 1069 code.wasm
</code></pre>
<p>And now the important thing - the contract code is not an actor. So, what is a
contract code? I think that the easiest way to think about that is a <code>class</code> or
a <code>type</code> in programming. It defines some stuff about what can be done, but the
class itself is in most cases not very useful unless we create an instance
of a type, on which we can call class methods. So now let's move forward to
instances of such contract classes.</p>
<h2 id="contract-instance"><a class="header" href="#contract-instance">Contract instance</a></h2>
<p>Now we have a contract code, but what we want is an actual contract itself.
To create it, we need to instantiate it. Relating to analogy to programming,
instantiation is calling a constructor. To do that, I would send an
instantiate message to my contract:</p>
<pre><code class="language-bash">$ wasmd tx wasm instantiate 1069 '{&quot;members&quot;: []}' --from wallet --label &quot;Group 1&quot; --no-admin $TXFLAG -y
</code></pre>
<p>What I do here is create a new contract and immediately call the <code>Instantiate</code>
message on it. The structure of such a message is different for every contract
code. In particular, the <code>cw4-group</code> Instantiate message contains two fields:</p>
<ul>
<li><code>members</code> field which is the list of initial group members optional <code>admin</code></li>
<li>field which defines an address of who can add or remove
a group member</li>
</ul>
<p>In this case, I created an empty group with no admin - so which could never
change! It may seem like a not very useful contract, but it serves us as a
contract example.</p>
<p>As the result of instantiating, I got the result:</p>
<pre><code>..
logs:
..
- events:
  ..
  - attributes:
    - key: _contract_address
      value: wasm1u0grxl65reu6spujnf20ngcpz3jvjfsp5rs7lkavud3rhppnyhmqqnkcx6
    - key: code_id
      value: &quot;1069&quot;
    type: instantiate
</code></pre>
<p>As you can see, we again look at <code>logs[].events[]</code> field, looking for
interesting event and extracting information from it - it is the common case.
I will talk about events and their attributes in the future but in general,
it is a way to notify the world that something happened. Do you remember the
KFC example? If a waiter is serving our dish, he would put a tray on the bar,
and she would yell (or put on the screen) the order number - this would be
announcing an event, so you know some summary of operation, so you can go and
do something useful with it.</p>
<p>So, what use can we do with the contract? We obviously can call it! But first
I want to tell you about addresses.</p>
<h2 id="addresses-in-cosmwasm"><a class="header" href="#addresses-in-cosmwasm">Addresses in CosmWasm</a></h2>
<p>Address in CosmWasm is a way to refer to entities in the blockchain. There are
two types of addresses: contract addresses, and non-contracts. The difference
is that you can send messages to contract addresses, as there is some smart
contract code associated with them, and non-contracts are just users of the
system. In an actor model, contract addresses represent actors, and
non-contracts represent clients of the system.</p>
<p>When operating with blockchain using <code>wasmd</code>, you also have an address - you
got one when you added the key to <code>wasmd</code>:</p>
<pre><code class="language-bash"># add wallets for testing
$ wasmd keys add wallet3
- name: wallet3
  type: local
  address: wasm1dk6sq0786m6ayg9kd0ylgugykxe0n6h0ts7d8t
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;Ap5zuScYVRr5Clz7QLzu0CJNTg07+7GdAAh3uwgdig2X&quot;}'
  mnemonic: &quot;&quot;
</code></pre>
<p>You can always check your address:</p>
<pre><code class="language-bash">$ wasmd keys show wallet
- name: wallet
  type: local
  address: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
  pubkey: '{&quot;@type&quot;:&quot;/cosmos.crypto.secp256k1.PubKey&quot;,&quot;key&quot;:&quot;A5bBdhYS/4qouAfLUH9h9+ndRJKvK0co31w4lS4p5cTE&quot;}'
  mnemonic: &quot;&quot;
</code></pre>
<p>Having an address is very important because it is a requirement for being able
to call anything. When we send a message to a contract it always knows the
address which sends this message so it can identify it - not to mention that
this sender is an address that would play a gas cost.</p>
<h2 id="querying-the-contract"><a class="header" href="#querying-the-contract">Querying the contract</a></h2>
<p>So, we have our contract, let's try to do something with it - query would be the
easiest thing to do. Let's do it:</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1u0grxl65reu6spujnf20ngcpz3jvjfsp5rs7lkavud3rhppnyhmqqnkcx6 '{ &quot;list_members&quot;: {} }'
data:
  members: []
</code></pre>
<p>The <code>wasm...</code> string is the contract address, and you have to substitute it with
your contract address. <code>{ &quot;list_members&quot;: {} }</code> is query message we send to
contract. Typically, CW smart contract queries are in the form of a single JSON
object, with one field: the query name (<code>list_members</code> in our case). The value
of this field is another object, being query parameters - if there are any.
<code>list_members</code> query handles two parameters: <code>limit</code>, and <code>start_after</code>, which
are both optional and which support result pagination. However, in our case of
an empty group they don't matter.</p>
<p>The query result we got is in human-readable text form (if we want to get the
JSON from - for example, to process it further with <code>jq</code>, just pass the
<code>-o json</code> flag). As you can see response contains one field: <code>members</code> which is
an empty array.</p>
<p>So, can we do anything more with this contract? Not much. But let's try to do
something with a new one!</p>
<h2 id="executions-to-perform-some-actions"><a class="header" href="#executions-to-perform-some-actions">Executions to perform some actions</a></h2>
<p>The problem with our previous contract is that for the <code>cw4-group</code> contract,
the only one who can perform executions on it is an admin, but our contract
doesn't have one. This is not true for every smart contract, but it is the
nature of this one.</p>
<p>So, let's make a new group contract, but this time we would
make ourselves an admin. First, check our wallet address:</p>
<pre><code class="language-bash">$ wasmd keys show wallet
</code></pre>
<p>And instantiate a new group contract - this time with proper admin:</p>
<pre><code class="language-bash">$ wasmd tx wasm instantiate 1069 '{&quot;members&quot;: [], &quot;admin&quot;: &quot;wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx&quot;}' --from wallet --label &quot;Group 1&quot; --no-admin $TXFLAG -y
..
logs:
- events:
  ..
  - attributes:
    - key: _contract_address
      value: wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u
    - key: code_id
      value: &quot;1069&quot;
    type: instantiate
</code></pre>
<p>You may ask, why do we pass some kind of <code>--no-admin</code> flag, if we just said, we
want to set an admin to the contract? The answer is sad and confusing, but...
it is a different admin. The admin we want to set is one checked by the
contract itself and managed by him. The admin which is declined with
<code>--no-admin</code> flag, is a wasmd-level admin, which can migrate the contract. You
don't need to worry about the second one at least until you learn about
contract migrations - until then you can always pass the <code>--no-admin</code> flag to
the contract.</p>
<p>Now let's query our new contract for the member's list:</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;list_members&quot;: {} }'
data:
  members: []
</code></pre>
<p>Just like before - no members initially. Now check an admin:</p>
<pre><code>$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;admin&quot;: {} }'
data:
  admin: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
</code></pre>
<p>So, there is an admin, it seems like the one we wanted to have there. So now we
would add someone to the group - maybe ourselves?</p>
<pre><code class="language-bash">wasmd tx wasm execute wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;update_members&quot;: { &quot;add&quot;: [{ &quot;addr&quot;: &quot;wasm1um59mldkdj8ayl5gkn
p9pnrdlw33v40sh5l4nx&quot;, &quot;weight&quot;: 1 }], &quot;remove&quot;: [] } }' --from wallet $TXFLAG -y
</code></pre>
<p>The message for modifying the members is <code>update_members</code> and it has two
fields: members to remove, and members to add. Members to remove are
just addresses. Members to add have a bit more complex structure: they
are records with two fields: address and weight. Weight is not relevant
for us now, it is just metadata stored with every group member - for
us, it would always be 1.</p>
<p>Let's query the contract again to check if our message changed anything:</p>
<pre><code class="language-bash">$ wasmd query wasm contract-state smart wasm1n5x8hmstlzdzy5jxd70273tuptr4zsclrwx0nsqv7qns5gm4vraqeam24u '{ &quot;list_members&quot;: {} }'
data:
  members:
  - addr: wasm1um59mldkdj8ayl5gknp9pnrdlw33v40sh5l4nx
    weight: 1
</code></pre>
<p>As you can see, the contract updated its state. This is basically how
it works - sending messages to contracts causes them to update the state,
and the state can be queried at any time. For now, to keep things simple
we were just interacting with the contract directly by <code>wasmd</code>, but as described
before - contracts can communicate with each other. However, to investigate
this we need to understand how to write contracts. Next time we will look
at the contract structure and we will map it part by part to what we have learned
until now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-contract-as-an-actor"><a class="header" href="#smart-contract-as-an-actor">Smart contract as an actor</a></h1>
<p>In previous chapters, we talked about the actor model and how it is implemented
in the blockchain. Now it is time to look closer into the typical contract
structure to understand how different features of the actor model are mapped to
it.</p>
<p>This will not be a step-by-step guide on contract creation, as it is a topic
for the series itself. It would be going through contract elements roughly to
visualize how to handle architecture in the actor model.</p>
<h2 id="the-state"><a class="header" href="#the-state">The state</a></h2>
<p>As before we would start with the state. Previously we were working with
the <code>cw4-group</code> contract, so let's start by looking at its code. Go to
<code>cw-plus/contracts/cw4-group/src</code>. The folder structure should look like
this:</p>
<pre><code class="language-bash">  src
├──  contract.rs
├──  error.rs
├──  helpers.rs
├──  lib.rs
├──  msg.rs
└──  state.rs
</code></pre>
<p>As you may already figure out, we want to check the <code>state.rs</code> first.</p>
<p>The most important thing here is a couple of constants: <code>ADMIN</code>, <code>HOOKS</code>,
<code>TOTAL</code>, and <code>MEMBERS</code>. Every one of such constants represents a single portion
of the contract state - as tables in databases. The types of those constants
represent what kind of table this is. The most basic ones are <code>Item&lt;T&gt;</code>, which
keeps zero or one element of a given type, and <code>Map&lt;K, T&gt;</code> which is a key-value
map.</p>
<p>You can see <code>Item</code> is used to keep an admin and some other data: <code>HOOKS</code>, and
<code>TOTAL</code>. <code>HOOKS</code> is used by the <code>cw4-group</code> to allow subscription to any
changes to a group - a contract can be added as a hook, so when the group
changes, a message is sent to it. The <code>TOTAL</code> is just a sum of all members'
weights.</p>
<p>The <code>MEMBERS</code> in the group contract is the <code>SnapshotMap</code> - as you can imagine,
it is a <code>Map</code>, with some steroids - this particular one, gives us access to the
state of the map at some point in history, accessing it by the blockchain
<code>height</code>. <code>height</code> is the count of blocks created since the beggining of
blockchain, and it is the most atomic time representation in smart contracts.
There is a way to access the clock time in them, but everything happening in a
single block is considered happening in the same moment.</p>
<p>Other types of storage objects not used in group contracts are:</p>
<ul>
<li><code>IndexedMap</code> - another map type, that allows accessing values
by a variety of keys</li>
<li><code>IndexedSnapshotMap</code> - <code>IndexedMap</code> and <code>SnapshotMap</code> married</li>
</ul>
<p>What is very important - every state type in the contract is accessed using
some name. All of those types are not containers, just accessors to the state.
Do you remember that I told you before that blockchain is our database? And
that is correct! All those types are just ORM to this database - when we use
them to get actual data from it, we pass a special <code>State</code> object to them, so
they can retrieve items from it.</p>
<p>You may ask - why all that data for a contract are not auto-fetched by
whatever is running it. That is a good question. The reason is that we want
contracts to be lazy with fetching. Copying data is a very expensive operation,
and for everything happening on it, someone has to pay - it is realized by gas
cost. I told you before, that as a contract developer you don't need to worry
about gas at all, but it was only partially true. You don't need to know
exactly how gas is calculated, but by lowering your gas cost, you would may
execution of your contracts cheaper which is typically a good thing. One good
practice to achieve that is to avoid fetching data you will not use in a
particular call.</p>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>In a blockchain, contracts communicate with each other by some JSON
messages. They are defined in most contracts in the <code>msg.rs</code> file. Take
a look at it.</p>
<p>There are three types on it, let's go through them one by one.
The first one is an <code>InstantiateMsg</code>. This is the one, that is sent
on contract instantiation. It typically contains some data which
is needed to properly initialize it. In most cases, it is just a
simple structure.</p>
<p>Then there are two enums: <code>ExecuteMsg</code>, and <code>QueryMsg</code>. They are
enums because every single variant of them represents a different
message which can be sent. For example, the <code>ExecuteMsg::UpdateAdmin</code>
corresponds to the <code>update_admin</code> message we were sending previously.</p>
<p>Note, that all the messages are attributed with
<code>#[derive(Serialize, Deserialize)]</code>, and
<code>#[serde(rename_all=&quot;snake_case&quot;)]</code>. Those attributes come from
the <a href="https://serde.rs/">serde</a> crate, and they help us with
deserialization of them (and serialization in case of sending
them to other contracts). The second one is not required,
but it allows us to keep a camel-case style in our Rust code,
and yet still have JSONs encoded with a snake-case style more
typical to this format.</p>
<p>I encourage you to take a closer look at the <code>serde</code> documentation,
like everything there, can be used with the messages.</p>
<p>One important thing to notice - empty variants of those enums,
tend to use the empty brackets, like <code>Admin {}</code> instead of
more Rusty <code>Admin</code>. It is on purpose, to make JSONs cleaner,
and it is related to how <code>serde</code> serializes enum.</p>
<p>Also worth noting is that those message types are not set in stone,
they can be anything. This is just a convention, but sometimes
you would see things like <code>ExecuteCw4Msg</code>, or similar. Just keep
in mind, to keep your message name obvious in terms of their
purpose - sticking to <code>ExecuteMsg</code>/<code>QueryMsg</code> is generally a good
idea.</p>
<h2 id="entry-points-1"><a class="header" href="#entry-points-1">Entry points</a></h2>
<p>So now, when we have our contract message, we need a way to handle
them. They are sent to our contract via entry points. There are
three entry points in the <code>cw4-group</code> contract:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
}
#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -&gt; Result&lt;Response, ContractError&gt; {
    // ..
}
#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p>Those functions are called by the CosmWasm virtual machine when
a message is to be handled by contract. You can think about them
as the <code>main</code> function of normal programs, except they have a signature
that better describes the blockchain itself.</p>
<p>What is very important is that the names of those entry points (similarly to
the <code>main</code> function) are fixed - it is relevant, so the virtual machine knows
exactly what to call.</p>
<p>So, let's start with the first line. Every entry point is attributed with
<code>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]</code>. It may look a bit
scary, but it is just a conditional equivalent of <code>#[entry_point]</code> -
the attribute would be there if and only if the &quot;library&quot; feature is not set.
We do this to be able to use our contracts as dependencies for other
contracts - the final binary can contain only one copy of each entry point,
so we make sure, that only the top-level one is compiled without this
feature.</p>
<p>The <code>entry_point</code> attribute is a macro that generates some boilerplate.
As the binary is run by WASM virtual machine, it doesn't know much about
Rust types - the actual entry point signatures are very inconvenient to
use. To overcome this issue, there is a macro created, which generates
entry points for us, and those entry points are just calling our functions.</p>
<p>Now take a look at functions arguments. Every single entry point takes as
the last argument a message which triggered the execution of it (except for
<code>reply</code> - I will explain it later). In addition to that, there are
additional arguments provided by blockchain:</p>
<ul>
<li><code>Deps</code> or <code>DepsMut</code> object is the gateway to the world outside the smart contract context. It allows
accessing the contract state, as well as querying other contracts, and
also delivers an <code>Api</code> object with a couple of useful utility functions.
The difference is that <code>DepsMut</code> allows updating state, while <code>Deps</code>
allows only to look at it.</li>
<li><code>Env</code> object delivers information about the blockchain state at the
moment of execution - its height, the timestamp of execution and information
about the executing contract itself.</li>
<li><code>MessageInfo</code> object is information about the contract call - it
contains the address which sends the message, and the funds sent with the
message.</li>
</ul>
<p>Keep in mind, that the signatures of those functions are fixed (except
the messages type), so you cannot interchange <code>Deps</code> with <code>DepsMut</code> to
update the contract state in the query call.</p>
<p>The last portion of entry points is the return type. Every entry point returns
a <code>Result</code> type, with any error which can be turned into a string - in case of
contract failure, the returned error is just logged. In most cases, the error
type is defined for a contract itself, typically using a
<a href="https://docs.rs/thiserror/latest/thiserror/">thiserror</a> crate. <code>Thiserror</code> is
not required here, but is strongly recommended - using it makes the error
definition very straightforward, and also improves the testability of the
contract.</p>
<p>The important thing is the <code>Ok</code> part of <code>Result</code>. Let's start with the
<code>query</code> because this one is the simplest. The query always returns the <code>Binary</code>
object on the <code>Ok</code> case, which would contain just serialized response.
The common way to create it is just calling a <code>to_binary</code> method
on an object implementing <code>serde::Serialize</code>, and they are typically
defined in <code>msg.rs</code> next to message types.</p>
<p>Slightly more complex is the return type returned by any other entry
point - the <code>cosmwasm_std::Response</code> type. This one keep everything
needed to complete contract execution. There are three chunks of
information in that.</p>
<p>The first one is an <code>events</code> field. It contains all events, which would
be emitted to the blockchain as a result of the execution. Events have
a really simple structure: they have a type, which is just a string,
and a list of attributes which are just string-string key-value pairs.</p>
<p>You can notice that there is another <code>attributes</code> field on the <code>Response</code>.
This is just for convenience - most executions would return
only a single event, and to make it a bit easier to operate one, there
is a set of attributes directly on response. All of them would be converted
to a single <code>wasm</code> event which would be emitted. Because of that, I consider
<code>events</code> and <code>attributes</code> to be the same chunk of data.</p>
<p>Then we have the messages field, of <code>SubMsg</code> type. This one is the clue
of cross-contact communication. Those messages would be sent to the
contracts after processing. What is important - the whole execution is
not finished, unless the processing of all sub-messages scheduled by the contract
finishes. So, if the group contract sends some messages as a result of
<code>update_members</code> execution, the execution would be considered done only if
all the messages sent by it would also be handled (even if they failed).</p>
<p>So, when all the sub-messages sent by contract are processed, then all the
attributes generated by all sub-calls and top-level calls are collected and
reported to the blockchain. But there is one additional piece of information -
the <code>data</code>. So, this is another <code>Binary</code> field, just like the result of a query
call, and just like it, it typically contains serialized JSON. Every contract
call can return some additional information in any format. You may ask - in
this case, why do we even bother returning attributes? It is because of a
completely different way of emitting events and data. Any attributes emitted by
the contract would be visible on blockchain eventually (unless the whole
message handling fails). So, if your contract emitted some event as a result of
being sub-call of some bigger use case, the event would always be there visible
to everyone. This is not true for data. Every contract call would return only
a single <code>data</code> chunk, and it has to decide if it would just forward the <code>data</code>
field of one of the sub-calls, or maybe it would construct something by itself.
I would explain it in a bit more detail in a while.</p>
<h2 id="sending-submessages"><a class="header" href="#sending-submessages">Sending submessages</a></h2>
<p>I don't want to go into details of the <code>Response</code> API, as it can be read
directly from documentation, but I want to take a bit closer look at the part
about sending messages.</p>
<p>The first function to use here is <code>add_message</code>, which takes as an argument the
<code>CosmosMsg</code> (or rather anything convertible to it). A message added to response
this way would be sent and processed, and its execution would not affect the
result of the contract at all.</p>
<p>The other function to use is <code>add_submessage</code>, taking a <code>SubMsg</code> argument. It
doesn't differ much from <code>add_message</code> - <code>SubMsg</code> just wraps the <code>CosmosMsg</code>,
adding some info to it: the <code>id</code> field, and <code>reply_on</code>. There is also a
<code>gas_limit</code> thing, but it is not so important - it just causes sub-message
processing to fail early if the gas threshold is reached.</p>
<p>The simple thing is <code>reply_on</code> - it describes if the <code>reply</code> message should be
sent on processing success, on failure, or both.</p>
<p>The <code>id</code> field is an equivalent of the order id in our KFC example from the
very beginning. If you send multiple different sub-messages, it would be
impossible to distinguish them without that field. It would not even be
possible to figure out what type of original message reply handling is! This is
why the <code>id</code> field is there - sending a sub-message you can set it to any
value, and then on the reply, you can figure out what is happening based on
this field.</p>
<p>An important note here - you don't need to worry about some sophisticated way
of generating ids. Remember, that the whole processing is atomic, and only one
execution can be in progress at once. In most cases, your contract sends a
fixed number of sub-messages on very concrete executions. Because of that, you
can hardcode most of those ids while sending (preferably using some constant).</p>
<p>To easily create submessages, instead of setting all the fields separately,
you would typically use helper constructors: <code>SubMsg::reply_on_success</code>,
<code>SubMsg::reply_on_error</code> and <code>SubMsg::reply_always</code>.</p>
<h2 id="cosmosmsg"><a class="header" href="#cosmosmsg">CosmosMsg</a></h2>
<p>If you took a look at the <code>CosmosMsg</code> type, you could be very surprised - there
are so many variants of them, and it is not obvious how they relate to
communication with other contracts.</p>
<p>The message you are looking for is the <code>WasmMsg</code> (<code>CosmosMsg::Wasm</code> variant).
This one is very much similar to what we already know - it has a couple of
variants of operation to be performed by contracts: <code>Execute</code>, but also
<code>Instantiate</code> (so we can create new contracts in contract executions), and also
<code>Migrate</code>, <code>UpdateAdmin</code>, and <code>ClearAdmin</code> - those are used to manage
migrations (will tell a bit about them at the end of this chapter).</p>
<p>Another interesting message is the <code>BankMsg</code> (<code>CosmosMsg::Bank</code>). This one
allows a contract to transfer native tokens to other contracts (or burn them -
equivalent to transferring them to some black whole contract). I like to think
about it as sending a message to a very special contract responsible for handling
native tokens - this is not a true contract, as it is handled by the blockchain
itself, but at least to me it simplifies things.</p>
<p>Other variants of <code>CosmosMsg</code> are not very interesting for now. The <code>Custom</code>
one is there to allow other CosmWasm-based blockchains to add some
blockchain-handled variant of the message. This is a reason why most
message-related types in CosmWasm are generic over some <code>T</code> - this is just a
blockchain-specific type of message. We will never use it in the <code>wasmd</code>. All
other messages are related to advanced CosmWasm features, and I will not
describe them here.</p>
<h2 id="reply-handling"><a class="header" href="#reply-handling">Reply handling</a></h2>
<p>So now that we know how to send a submessage, it is time to talk about
handling the reply. When sub-message processing is finished, and it is
requested to reply, the contract is called with an entry point:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn reply(deps: DepsMut, env: Env, msg: Reply) -&gt; Result&lt;Response, ContractError&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>DepsMut</code>, and <code>Env</code> arguments are already familiar, but there is a new
one, substituting the typical message argument: the <code>cosmwasm_std::Reply</code>.</p>
<p>This is a type representing the execution status of the sub-message. It is
slightly processed <code>cosmwasm_std::Response</code>. The first important thing it contains
is an <code>id</code> - the same, which you set sending sub-message, so now you can
identify your response. The other one is the <code>ContractResult</code>, which is very
similar to the Rust <code>Result&lt;T, String&gt;</code> type, except it is there for
serialization purposes. You can easily convert it into a <code>Result</code> with an
<code>into_result</code> function.</p>
<p>In the error case of <code>ContracResult</code>, there is a string - as I mentioned
before, errors are converted to strings right after execution. The <code>Ok</code> case
contains <code>SubMsgExecutionResponse</code> with two fields: <code>events</code> emitted by
sub-call, and the <code>data</code> field embedded on response.</p>
<p>As said before, you never need to worry about forwarding events - CosmWasm
would do it anyway. The <code>data</code> however, is another story. As mentioned before,
every call would return only a single data object. In the case of sending
sub-messages and not capturing a reply, it would always be whatever is returned
by the top-level message. But it is not the case when <code>reply</code> is called. If a
a reply is called, then it is a function deciding about the final <code>data</code>. It can
decide to either forward the data from the sub-message (by returning <code>None</code>) or
to overwrite it. It cannot choose, to return data from the original execution
processing - if the contract sends sub-messages waiting for replies, it is
supposed to not return any data, unless replies are called.</p>
<p>But what happens if multiple sub-messages are sent? What would the final
<code>data</code> contain? The rule is - the last non-None. All sub-messages are always
called in the order of adding them to the <code>Response</code>. As the order is
deterministic and well defined, it is always easy to predict which reply would
be used.</p>
<h2 id="migrations"><a class="header" href="#migrations">Migrations</a></h2>
<p>I mentioned migrations earlier when describing the <code>WasmMsg</code>. So, migration
is another action possible to be performed by contracts, which is kind
of similar to instantiate. In software engineering, it is a common thing to
release an updated version of applications. It is also a case in the blockchain -
SmartContract can be updated with some new features. In such cases, a new
code is uploaded, and the contract is migrated - so it knows that from
this point, its messages are handled by another, updated contract code.</p>
<p>However, it may be that the contract state used by the older version of the
contract differs from the new one. It is not a problem if some info was
added (for example some additional map - it would be just empty right
after migration). But the problem is, when the state changes,
for example, the field is renamed. In such a case, every contract execution
would fail because of (de)serialization problems. Or even more subtle
cases, like adding a map, but one which should be synchronized with the whole
contract state, not empty.</p>
<p>This is the purpose of the <code>migration</code> entry point. It looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn migrate(deps: DepsMut, env: Env, msg: MigrateMsg) -&gt; Result&lt;Response&lt;T&gt;, ContracError&gt; {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p><code>MigrateMsg</code> is the type defined by the contract in <code>msg.rs</code>.
The <code>migrate</code> entry point would be called at the moment of performing
the migration, and it is responsible for making sure the state is correct
after the migration. It is very similar to schema migrations in traditional
database applications. And it is also kind of difficult, because of version
management involved - you can never assume, that you are migrating a contract
from the previous version - it can be migrated from any version, released
anytime - even later than that version we are migrating to!</p>
<p>It is worth bringing back one issue from the past - the contract admin. Do you
remember the <code>--no-admin</code> flag we set previously on every contract
instantiation? It made our contract unmigrateable. Migrations can be performed
only by contract admin. To be able to use it, you should pass <code>--admin address</code>
flag instead, with the <code>address</code> being the address that would be able to
perform migrations.</p>
<h2 id="sudo"><a class="header" href="#sudo">Sudo</a></h2>
<p>Sudo is the last basic entry point in <code>CosmWasm</code>, and it is the one we would
never use in <code>wasmd</code>. It is equivalent to <code>CosmosMsg::Custom</code>, but instead of
being a special blockchain-specific message to be sent and handled by a
blockchain itself, it is now a special blockchain-specific message sent by the
blockchain to contract in some conditions. There are many uses for those, but I
will not cover them, because would not be related to <code>CosmWasm</code> itself. The
signature of <code>sudo</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg_attr(not(feature = &quot;library&quot;), entry_point)]
pub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -&gt; Result&lt;Response, ContractError&gt; {
    // ..
}
<span class="boring">}
</span></code></pre></pre>
<p>The important difference is that because <code>sudo</code> messages are blockchain
specific, the <code>SudoMsg</code> type is typically defined by some blockchain helper
crate, not the contract itself.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-contract-communication"><a class="header" href="#cross-contract-communication">Cross contract communication</a></h1>
<p>We already covered creating a single isolating contract. However, SOLID principles tell us that
entities should be as small as reasonably possible - such as they have a
<a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">single responsibility</a>. Entities
we are focusing on now are smart contracts, and we want to make sure that every smart contract has
a sole responsibility it takes care of.</p>
<p>But we also want to build complex systems using smart contracts. To do so, we need to be able to
communicate between them. We already talked about what such communication looks like using an actor
model. Now it's time to use this knowledge in practice.</p>
<p>In this chapter, we will improve the previously created administration group model to solve the problem
I brought - the possibility of adding own multiple addresses by a single admin to take bigger donation parts.</p>
<p>We would also give admins some work to do besides being admins.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>This time we will start discussing the design of our system a bit. Building multi-contract systems tend to
be a bit more complicated than just isolated contracts, so I want to give you some anchor on what we are
building in this chapter. If you feel lost with a design, don't worry - it will get clear while implementing
contracts. For now, go through it to get a general idea.</p>
<p>First, let's think about the problem we want to solve. Our admins are a vector of addresses. Anyone already
an admin can add anyone he wants to the list. But this &quot;anyone&quot; can be a second instance of the same admin
account, so he counts twice for donations!</p>
<p>This issue is relatively simple to fix, but there is another problem - as we already learned, the admin could
create a smart contract which he and only he can withdraw tokens from and register as another admin in the
group! Instantiating it multiple times, he can achieve his goal even if we prevent adding the same address
multiple times. There would be many distinct addresses that the same person owns.</p>
<p>It looks like an unpleasant situation, but there are ways to manage it. The one we would implement is voting.
Instead of being able to add another admin to the list, admins would be allowed to propose their colleagues
as new admins. It would start a voting process - everyone who was an admin at the time of the proposal creation
would be able to support it. If more than half admins would support the new candidate, he would immediately
become an admin.</p>
<p>It is not the most convoluted voting process, but it would be enough for our purposes.</p>
<h2 id="voting-process"><a class="header" href="#voting-process">Voting process</a></h2>
<p>To achieve this goal, we would create two smart contracts. First, one would be reused contract from the
<a href="cross-contract/../basics.html">Basics</a> chapter - it would be an <code>admin</code> contract. Additionally, we would add a <code>voting</code> contract.
It would be responsible for managing a single voting process. It would be instantiated by an <code>admin</code> contract
whenever an admin wants to add his friend to a list. Here is a diagram of the contracts relationship:</p>
<p><img src="cross-contract/../mdbook-plantuml-img/66f4c7e9766997a755cbf3507f13144b5787e5da.svg" alt="" /></p>
<p>Here is adding an admin flowchart - assuming there are 5 admins on the contract already, but 2 of them did nothing:</p>
<p><img src="cross-contract/../mdbook-plantuml-img/6528660a9f88cc401fb1b6e62181485b144687ae.svg" alt="" /></p>
<p>I already put some hints about contracts implementation, but I will not go into them yet.</p>
<h2 id="messages-forwarding"><a class="header" href="#messages-forwarding">Messages forwarding</a></h2>
<p>There is one other thing we want to add - some way to give admins work. The <code>admin</code> contract would behave like
a proxy to call another contract. That means that some other external contract would just set our <code>admin</code> instance
as a specific address that can perform executions on it, and admins would perform actions this way. The external
contract would see execution as the admin contract would do it. Here is an updated contracts diagram:</p>
<p><img src="cross-contract/../mdbook-plantuml-img/5ea499d765387fa9c0342773a37395cb916614ef.svg" alt="" /></p>
<p>And calling external contract flowchart:</p>
<p><img src="cross-contract/../mdbook-plantuml-img/071046fb2dd72667d935d09a8cb4c0c5108e8ee3.svg" alt="" /></p>
<p>Note that the <code>msg</code> on <code>execute</code> admin contract message is some arbitrary message just forwarded
to the external contract. It would be a base64-encoded message in the real world, but it is
just an implementation detail.</p>
<p>Ultimately, we will create a simple example of an external contract to understand how to use such a pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fixing-admin-contract"><a class="header" href="#fixing-admin-contract">Fixing admin contract</a></h1>
<p>Now that we know what we want to achieve, we can start by aligning the
contract we already have to become an admin contract. It is primarily
fine at this point, but we want to do a cleanup.</p>
<h2 id="cleaning-up-queries"><a class="header" href="#cleaning-up-queries">Cleaning up queries</a></h2>
<p>The first thing to do is to get rid of the <code>Greet</code> query - it was good as a
starter query example, but it has no practical purpose and only generates noise.</p>
<p>We want to remove the unnecessary variant from the query enum:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cosmwasm_schema::{cw_serde, QueryResponses};
</span><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct InstantiateMsg {
</span><span class="boring">    pub admins: Vec&lt;String&gt;,
</span><span class="boring">    pub donation_denom: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub enum ExecuteMsg {
</span><span class="boring">    Leave {},
</span><span class="boring">    Donate {},
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cw_serde]
</span><span class="boring">pub struct AdminsListResp {
</span><span class="boring">    pub admins: Vec&lt;Addr&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(AdminsListResp)]
    AdminsList {},
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we also remove the invalid path in the query dispatcher:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -&gt; StdResult&lt;Binary&gt; {
    use QueryMsg::*;

    match msg {
        AdminsList {} =&gt; to_binary(&amp;query::admins_list(deps)?),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we remove the irrelevant handler from the <code>contract::query</code> module.
We also need to make sure all references to it are gone (eg. if there are any
in the tests).</p>
<h2 id="generating-the-library-output"><a class="header" href="#generating-the-library-output">Generating the library output</a></h2>
<p>At the very beginning of the book, we set the <code>crate-type</code> in <code>Cargo.toml</code> as
<code>&quot;cdylib&quot;</code>. It was required to generate the wasm output, but it comes with a
drawback - the dynamic libraries, as this cannot be used as dependencies in
other crates. It was not a problem before, but in practice we often want to
depend contract on others to get access to some types of them - for example,
defined messages.</p>
<p>Good for us. It is easy to fix. You might notice that the <code>crate-type</code> is an array,
not a single string. The reason for that is that our project can emit several
targets - in particular, we can add there the default <code>&quot;rlib&quot;</code> crate type to
make it generate a &quot;rust library&quot; output - which is what we need to use as a
dependency. Let's update our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;admin&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[lib]
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]
# 
# [features]
# library = []
# 
# [dependencies]
# cosmwasm-std = { version = &quot;1.1.4&quot;, features = [&quot;staking&quot;] }
# serde = { version = &quot;1.0.103&quot;, default-features = false, features = [&quot;derive&quot;] }
# cw-storage-plus = &quot;0.15.1&quot;
# thiserror = &quot;1&quot;
# schemars = &quot;0.8.1&quot;
# cw-utils = &quot;0.15.1&quot;
# cosmwasm-schema = &quot;1.1.4&quot;
# 
# [dev-dependencies]
# cw-multi-test = &quot;0.15.1&quot;
</code></pre>
<p>Also, note I changed the contract name - &quot;contract&quot; is not very descriptive, so
I updated it to &quot;admin&quot;.</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h2>
<p>Last but not least - we want to better structure our project. So far, we have
only one contract, so we just worked on it as a whole project. Now we want some
directory tree that reflects relations between contracts we create.</p>
<p>First, create a directory for the project. Then we want to create a &quot;contracts&quot;
subdirectory in it. It is not technically required from Rust's POV, but there
are tools in our environment, like the workspace optimizer, which would assume
it is where it should look for a contract. It is a common pattern you will see
in CosmWasm contracts repos.</p>
<p>Then we copy the whole project directory from the previous chapter into the
<code>contracts</code>, renaming it to <code>admin</code>.</p>
<p>Finally, we want to couple all our projects (for now, it is just one, but we know
there will be more there). To do so, we create the workspace-level <code>Cargo.toml</code>
file in the top-level project directory:</p>
<pre><code class="language-toml">[workspace]
members = [&quot;contracts/*&quot;]
resolver = &quot;2&quot;
</code></pre>
<p>This <code>Cargo.toml</code> differs slightly from the typical project-level one - it
defines the workspace. The most important field here is the <code>members</code> - it
defines projects being part of the workspace.</p>
<p>The other field is the <code>resolver</code>. It is something to remember to add - it
instructs cargo to use version 2 of the dependency resolver. This has been the
default for non-workspaces since Rust 2021, but because of compatibility reasons,
the default couldn't be changed for workspaces - but it is advised to add it to
every single newly created workspace.</p>
<p>The last field which might be useful for workspaces is exclude - it allows to
create projects in the workspace directory tree, which is not a part of this
workspace - we will not use it, but it is good to know about it.</p>
<p>Now just for clarity, let's see the top-level directory structure:</p>
<pre><code class="language-none">.
├── Cargo.lock
├── Cargo.toml
├── contracts
│  └── admin
└── target
   ├── CACHEDIR.TAG
   └── debug
</code></pre>
<p>You can see the target directory and <code>Cargo.lock</code> files existing in the tree - it is
because I already built and ran tests for the <code>admin</code> contract - in Rust workspaces,
`cargo`` knows to build everything in the top level, even if it would be built from
the inner directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-storage"><a class="header" href="#map-storage">Map storage</a></h1>
<p>There is one thing to be immediately improved in the admin contract. Let's
check the contract state:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use cosmwasm_std::Addr;
</span><span class="boring">use cw_storage_plus::Item;
</span><span class="boring">
</span>pub const ADMINS: Item&lt;Vec&lt;Addr&gt;&gt; = Item::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Note that we keep our admin list as a single vector. However, in the whole
contract, in most cases, we access only a single element of this vector.</p>
<p>This is not ideal, as now, whenever we want to access the single admin entry,
we have first to deserialize the list containing all of them and then iterate
over them until we find the interesting one. This might consume a serious
amount of gas and is completely unnecessary overhead - we can avoid that using
the <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html">Map</a>
storage accessor.</p>
<h2 id="the-map-storage"><a class="header" href="#the-map-storage">The <code>Map</code> storage</a></h2>
<p>First, let's define a map - in this context, it would be a set of keys with values
assigned to them, just like a <code>HashMap</code> in Rust or dictionaries in many languages.
We define it as similar to an <code>Item</code>, but this time we need two types - the key type
and the value type:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cw_storage_plus::Map;

pub const STR_TO_INT_MAP: Map&lt;String, u64&gt; = Map::new(&quot;str_to_int_map&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Then to store some items on the <a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html"><code>Map</code></a>,
we use a
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.save"><code>save</code></a>
method - same as for an <code>Item</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>STR_TO_INT_MAP.save(deps.storage, &quot;ten&quot;.to_owned(), 10);
STR_TO_INT_MAP.save(deps.storage, &quot;one&quot;.to_owned(), 1);
<span class="boring">}
</span></code></pre></pre>
<p>Accessing entries in the map is also as easy as reading an item:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ten = STR_TO_INT_MAP.load(deps.storage, &quot;ten&quot;.to_owned())?;
assert_eq!(ten, 10);

let two = STR_TO_INT_MAP.may_load(deps.storage, &quot;two&quot;.to_owned())?;
assert_eq!(two, None);
<span class="boring">}
</span></code></pre></pre>
<p>Obviously, if the element is missing in the map, the
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.load"><code>load</code></a>
function will result in an error - just like for an item. On the other hand -
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.may_load"><code>may_load</code></a>
returns a <code>Some</code> variant when element exits.</p>
<p>Another very useful accessor that is specific to the map is the
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.has"><code>has</code></a>
function, which checks for the existence of the key in the map:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let contains = STR_TO_INT_MAP.has(deps.storage, &quot;three&quot;.to_owned())?;
assert!(!contains);
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we can iterate over elements of the maps - either its keys or key-value
pairs:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::Order;

for k in STR_TO_INT_MAP.keys(deps.storage, None, None, Order::Ascending) {
    let _addr = deps.api.addr_validate(k?);
}

for item in STR_TO_INT_MAP.range(deps.storage, None, None, Order::Ascending) {
    let (_key, _value) = item?;
}
<span class="boring">}
</span></code></pre></pre>
<p>First, you might wonder about extra values passed to
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.keys"><code>keys</code></a>
and
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.range"><code>range</code></a> -
those are in order: lower and higher bounds of iterated elements, and the order
elements should be traversed.</p>
<p>While working with typical Rust iterators, you would probably first create an
iterator over all the elements and then somehow skip those you are not
interested in. After that, you will stop after the last interesting element.</p>
<p>It would more often than not require accessing elements you filter out, and
this is the problem - it requires reading the element from the storage. And
reading it from the storage is the expensive part of working with data, which
we try to avoid as much as possible. One way to do it is to instruct the Map
where to start and stop deserializing elements from storage so it never reaches
those outside the range.</p>
<p>Another critical thing to notice is that the iterator returned by both keys and
range functions are not iterators over elements - they are iterators over <code>Result</code>s.
It is a thing because, as it is rare, it might be that item is supposed to exist,
but there is some error while reading from storage - maybe the stored value is
serialized in a way we didn't expect, and deserialization fails. This is actually
a real thing that happened in one of the contracts I worked on in the past - we
changed the value type of the Map, and then forgot to migrate it, which caused
all sorts of problems.</p>
<h2 id="maps-as-sets"><a class="header" href="#maps-as-sets">Maps as sets</a></h2>
<p>So I imagine you can call me crazy right now - why do I spam about a <code>Map</code>, while
we are working with vector? It is clear that those two represent two distinct
things! Or do they?</p>
<p>Let's reconsider what we keep in the <code>ADMINS</code> vector - we have a list of objects
which we expect to be unique, which is a definition of a mathematical set. So
now let me bring back my initial definition of the map:</p>
<blockquote>
<p>First, let's define a map - in this context, it would be a <em>set</em> of keys with
values assigned to them, just like a HashMap in Rust or dictionaries in many languages.</p>
</blockquote>
<p>I purposely used the word &quot;set&quot; here - the map has the set built into it. It is
a generalization of a set or reversing the logic - the set is a particular case
of a map. If you imagine a set that map every single key to the same value, then
the values become irrelevant, and such a map becomes a set semantically.</p>
<p>How can you make a map mapping all the keys to the same value? We pick a type
with a single value. Typically in Rust, it would be a unit type (<code>()</code>), but in
CosmWasm, we tend to use the
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.Empty.html"><code>Empty</code></a>
type from CW standard crate:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Empty};
use cw_storage_plus::Map;

pub const ADMINS: Map&lt;Addr, Empty&gt; = Map::new(&quot;admins&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>We now need to fix the usage of the map in our contract. Let's start with contract
instantiation:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::msg::InstantiateMsg;
use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    DepsMut, Empty, Env, MessageInfo, Response, StdResult,
};

pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, admin, &amp;Empty {})?;
    }
    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;

    Ok(Response::new())
}
<span class="boring">}
</span></code></pre></pre>
<p>It didn't simplify much, but we no longer need to collect our address. Then
let's move to the leaving logic:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::ADMINS;
use cosmwasm_std::{DepsMut, MessageInfo};

pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
    ADMINS.remove(deps.storage, info.sender.clone());

    let resp = Response::new()
        .add_attribute(&quot;action&quot;, &quot;leave&quot;)
        .add_attribute(&quot;sender&quot;, info.sender.as_str());

    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we see a difference - we don't need to load a whole vector. We remove a
single entry with the
<a href="https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/struct.Map.html#method.remove"><code>remove</code></a>
function.</p>
<p>What I didn't emphasize before, and what is relevant, is that <code>Map</code> stores every
single key as a distinct item. This way, accessing a single element will be
cheaper than using a vector.</p>
<p>However, this has its downside - accessing all the elements is more
gas-consuming using Map! In general, we tend to avoid such situations - the
linear complexity of the contract might lead to very expensive executions
(gas-wise) and potential vulnerabilities - if the user finds a way to create
many dummy elements in such a vector, he may make the execution cost exceeding
any gas limit.</p>
<p>Unfortunately, we have such an iteration in our contract - the distribution flow
becomes as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::error::ContractError;
use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    coins, BankMsg,DepsMut, MessageInfo, Order, Response
};

pub fn donate(deps: DepsMut, info: MessageInfo) -&gt; Result&lt;Response, ContractError&gt; {
    let denom = DONATION_DENOM.load(deps.storage)?;
    let admins: Result&lt;Vec&lt;_&gt;, _&gt; = ADMINS
        .keys(deps.storage, None, None, Order::Ascending)
        .collect();
    let admins = admins?;

    let donation = cw_utils::must_pay(&amp;info, &amp;denom)?.u128();

    let donation_per_admin = donation / (admins.len() as u128);

    let messages = admins.into_iter().map(|admin| BankMsg::Send {
        to_address: admin.to_string(),
        amount: coins(donation_per_admin, &amp;denom),
    });

    let resp = Response::new()
        .add_messages(messages)
        .add_attribute(&quot;action&quot;, &quot;donate&quot;)
        .add_attribute(&quot;amount&quot;, donation.to_string())
        .add_attribute(&quot;per_admin&quot;, donation_per_admin.to_string());

    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<p>If I had to write a contract like this, and this <code>donate</code> would be a critical,
often called flow, I would advocate for going for an <code>Item&lt;Vec&lt;Addr&gt;&gt;</code> here.
Fortunately, it is not the case - the distribution does not have to be linear in
complexity! It might sound a bit crazy, as we have to iterate over all receivers
to distribute funds, but this is not true - there is a pretty nice way to do so
in constant time, which I will describe later in the book. For now, we will
leave it as it is, acknowledging the flaw of the contract, which we will fix later.</p>
<p>The final function to fix is the <code>admins_list</code> query handler:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::ADMINS;
use cosmwasm_std::{Deps, Order, StdResult};

pub fn admins_list(deps: Deps) -&gt; StdResult&lt;AdminsListResp&gt; {
    let admins: Result&lt;Vec&lt;_&gt;, _&gt; = ADMINS
        .keys(deps.storage, None, None, Order::Ascending)
        .collect();
    let admins = admins?;
    let resp = AdminsListResp { admins };
    Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we also have an issue with linear complexity, but it is far less of a problem.</p>
<p>First, queries are often purposed to be called on local nodes, with no gas cost -
we can query contracts as much as we want.</p>
<p>And then, even if we have some limit on execution time/cost, there is no reason to
query all the items every single time! We will fix this function later, adding
pagination - to limit the execution time/cost of the query caller would be able to
ask for a limited amount of items starting from the given one. Knowing this chapter,
you can probably figure implementation of it right now, but I will show the common
way we do that when I go through common CosmWasm practices.</p>
<h2 id="reference-keys"><a class="header" href="#reference-keys">Reference keys</a></h2>
<p>There is one subtlety to improve in our map usage.</p>
<p>The thing is that right now, we index the map with the owned Addr key. That forces
us to clone it if we want to reuse the key (particularly in the leave implementation).
This is not a huge cost, but we can avoid it - we can define the key of the map
to be a reference:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Empty};
use cw_storage_plus::Map;

pub const ADMINS: Map&lt;&amp;Addr, Empty&gt; = Map::new(&quot;admins&quot;);
pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we need to fix the usages of the map in two places:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use crate::state::{ADMINS, DONATION_DENOM};
</span><span class="boring">use cosmwasm_std::{
</span><span class="boring">    DepsMut, Empty, Env, MessageInfo, Response, StdResult,
</span><span class="boring">};
</span><span class="boring">
</span>pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, &amp;admin, &amp;Empty {})?;
    }

    // ...

<span class="boring">   DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;
</span><span class="boring">
</span>   Ok(Response::new())
}

pub fn leave(deps: DepsMut, info: MessageInfo) -&gt; StdResult&lt;Response&gt; {
    ADMINS.remove(deps.storage, &amp;info.sender);

    // ...

<span class="boring">   let resp = Response::new()
</span><span class="boring">       .add_attribute(&quot;action&quot;, &quot;leave&quot;)
</span><span class="boring">       .add_attribute(&quot;sender&quot;, info.sender.as_str());
</span><span class="boring">
</span>   Ok(resp)
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-time"><a class="header" href="#working-with-time">Working with time</a></h1>
<p>The concept of time in the blockchain is tricky - as in
every distributed system, it is not easy to synchronize the
clocks of all the nodes.</p>
<p>However, there is the notion of a time that is even
monotonic - which means that it should never go &quot;backward&quot;
between executions. Also, what is important is - time is
always unique throughout the whole transaction - and even
the entire block, which is built of multiple transactions.</p>
<p>The time is encoded in the
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.Env.html"><code>Env</code></a>
type in its
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.BlockInfo.html"><code>block</code></a>
field, which looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct BlockInfo {
    pub height: u64,
    pub time: Timestamp,
    pub chain_id: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>You can see the <code>time</code> field, which is the timestamp of the
processed block. The <code>height</code> field is also worth
mentioning - it contains a sequence number of the processed
block. It is sometimes more useful than time, as it is
guaranteed that the <code>height</code> field is guaranteed to increase
between blocks, while two blocks may be executed with the
same <code>time</code> (even though it is rather not probable).</p>
<p>Also, many transactions might be executed in a single block.
That means that if we need a unique id for the execution of
a particular message, we should look for something more.
This thing is a
<a href="https://docs.rs/cosmwasm-std/1.2.4/cosmwasm_std/struct.TransactionInfo.html"><code>transaction</code></a>
field of the <code>Env</code> type:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TransactionInfo {
    pub index: u32,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>index</code> here contains a unique index of the transaction
in the block. That means that to get the unique identifier
of a transaction through the whole block, we can use the
<code>(height, transaction_index)</code> pair.</p>
<h2 id="join-time"><a class="header" href="#join-time">Join time</a></h2>
<p>We want to use the time in our system to keep track of the
join time of admins. We don't yet add new members to the
group, but we can already set the join time of initial
admins. Let's start updating our state:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use cosmwasm_std::{Addr, Timestamp};
use cw_storage_plus::Map;
<span class="boring">use cw_storage_plus::Item;
</span>
pub const ADMINS: Map&lt;&amp;Addr, Timestamp&gt; = Map::new(&quot;admins&quot;);
<span class="boring">pub const DONATION_DENOM: Item&lt;String&gt; = Item::new(&quot;donation_denom&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<p>As you can see, our admins set became a proper map - we will
assign the join time to every admin.</p>
<p>Now we need to update how we initialize a map - we stored the Empty data previously, but it nevermore matches our value type. Let's check an updated instantiation function:</p>
<p>You might argue to create a separate structure for the value
of this map, so in the future, if we would need to add
something there, but in my opinion, it would be premature -
we can also change the entire value type in the future, as
it would be the same breaking change.</p>
<p>Now we need to update how we initialize a map - we stored
the <code>Empty</code> data previously, but it nevermore matches our
value type. Let's check an updated instantiation function:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::state::{ADMINS, DONATION_DENOM};
use cosmwasm_std::{
    DepsMut, Env, MessageInfo, Response, StdResult,
};

pub fn instantiate(
    deps: DepsMut,
    env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -&gt; StdResult&lt;Response&gt; {
    for addr in msg.admins {
        let admin = deps.api.addr_validate(&amp;addr)?;
        ADMINS.save(deps.storage, &amp;admin, &amp;env.block.time)?;
    }
    DONATION_DENOM.save(deps.storage, &amp;msg.donation_denom)?;

    Ok(Response::new())
}
<span class="boring">}
</span></code></pre></pre>
<p>Instead of storing <code>&amp;Empty {}</code> as an admin value, we store
the join time, which we read from <code>&amp;env.block.time</code>. Also,
note that I removed the underscore from the name of the
<code>env</code> block - it was there only to ensure the Rust compiler
the variable is purposely unused and not some kind of a bug.</p>
<p>Finally, remember to remove any obsolete <code>Empty</code> imports
through the project - the compiler should help you point out
unused imports.</p>
<h2 id="query-and-tests"><a class="header" href="#query-and-tests">Query and tests</a></h2>
<p>The last thing to add regarding join time is the new query
asking for the join time of a particular admin. Everything
you need to do that was already discussed, I'll leave it for
you as an exercise. The query variant should look like:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[returns(JoinTimeResp)]
JoinTime { admin: String },
<span class="boring">}
</span></code></pre></pre>
<p>And the example response type:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cw_serde]
pub struct JoinTimeResp {
    pub joined: Timestamp,
}
<span class="boring">}
</span></code></pre></pre>
<p>You may question that in response type, I suggest always returning a <code>joined</code>
value, but what to do when no such admin is added? Well, in such a case, I
would rely on the fact that <code>load</code> function returns a descriptive error of
missing value in storage - however, feel free to define your own error for such
a case or even make the <code>joined</code> field optional, and be returned if requested
admin exists.</p>
<p>Finally, there would be a good idea to make a test for new functionality - call
a new query right after instantiation to verify initial admins has proper join
time (possibly by extending the existing instantiation test).</p>
<p>One thing you might need help with in tests might be how to get the time of
execution. Using any OS-time would be doomed to fail - instead, you can call
the
<a href="https://docs.rs/cw-multi-test/0.16.4/cw_multi_test/struct.App.html#method.block_infohttps://docs.rs/cw-multi-test/0.16.4/cw_multi_test/struct.App.html#method.block_info"><code>block_info</code></a>
function to reach the
<a href="https://docs.rs/cosmwasm-std/latest/cosmwasm_std/struct.BlockInfo.html"><code>BlockInfo</code></a>
structure containing the block state at a particular moment in the app - calling
it just before instantiation would make you sure you are working with the same state
which would be simulated on the call.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="legal-information"><a class="header" href="#legal-information">Legal Information</a></h1>
<p>Infomation according to § 5 TMG</p>
<h2 id="provider"><a class="header" href="#provider">Provider</a></h2>
<p>Confio GmbH<br />
7th Floor<br />
Potsdamer Platz 1<br />
10785 Berlin</p>
<h2 id="managing-director"><a class="header" href="#managing-director">Managing Director</a></h2>
<p>Simon Warta</p>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p><a href="mailto:hello@confio.gmbh">hello@confio.gmbh</a></p>
<h2 id="commercial-register"><a class="header" href="#commercial-register">Commercial Register</a></h2>
<p>HRB 221575, Amtsgericht Charlottenburg</p>
<h2 id="vat-number"><a class="header" href="#vat-number">VAT number</a></h2>
<p>DE339802279</p>
<h2 id="responsible-for-the-content"><a class="header" href="#responsible-for-the-content">Responsible for the content</a></h2>
<p>Simon Warta<br />
c/o Confio GmbH<br />
7th Floor<br />
Potsdamer Platz 1<br />
10785 Berlin</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
